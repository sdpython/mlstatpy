\input{../../common/livre_begin.tex}%
\firstpassagedo{\input{image_titre.tex}}
\input{../../common/livre_table_begin.tex}%



\sloppy

%--------------------------------------------------------------------------------------------------------------
\chapter{Traitement d'images}
%--------------------------------------------------------------------------------------------------------------

\label{image_chapitre_label}


Ce chapitre regroupe tous les traitements d'images pr�alables � l'utilisation de mod�les probabilistes qu'on peut scinder en deux ensembles. Le premier corrige les imperfections de l'image comme un bruit importun, un soulignement non d�sir�, une mauvaise inclinaison. Le second groupe concerne essentiellement la segmentation en graph�mes qui consiste � d�couper l'image d'un mot cursif en petites images, ceci afin de r�duire la complexit� des mod�les probabilistes utilis�s par la suite. La premi�re id�e explor�e fut d'un apprentissage de cette segmentation. Les r�sultats insuffisants orient�rent ensuite ces travaux vers la r�alisation d'une segmentation � l'aide d'algorithmes plus classiques incluant notamment un traitement dissoci� des accents dont la pertinence a �t� �valu�e.


%--------------------------------------------------------------------------------------------------------------
\section{Pr�ambule}
%--------------------------------------------------------------------------------------------------------------

\indexfr{pr�traitement}

\indexfrr{s�quence}{observations}
\indexfrr{mot}{math�matique}

Avant de se lancer dans la reconnaissance � proprement parler, l'image doit �tre pr�trait�e de mani�re � passer d'une information souvent bruit�e, toujours de taille variable � une information standardis�e. Une s�rie de traitements parfois simples, parfois complexes est d'abord appliqu�e � l'image avant de la convertir en une s�quence d'observations ou mot math�matique, mat�riau utilis� par les mod�les de reconnaissance statistique. L'image d'un mot affronte des traitements tels que l'extraction de la zone � reconna�tre, la binarisation, le nettoyage, le redressement de l'inclinaison, la squelettisation, la segmentation en graph�mes, en mots (voir figure~\ref{image_global}).
            
            
            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=6cm, width=10cm]
        {\filext{../image/image/global}}\end{array}$}$$
        \caption{Sch�ma global des pr�traitements d'image.}
        \label{image_global}
            \end{figure}
            
\indexfr{heuristique}            
\indexfr{nettoyage}
\indexfr{graph�me}
Chacune de ces �tapes est souvent tr�s rapide et est fr�quemment bas�e sur des heuristiques. L'extraction, la binarisation, la squelettisation\seeannex{annexe_squelettisation}{squelettisation} sont des traitements communs qui ne seront pas plus d�taill�s. Le nettoyage est en pratique adapt� pour chaque type de probl�me. Le nettoyage d'un peigne est diff�rent du nettoyage d'une ligne et il n'existe pas encore de m�thode g�n�rale pour ce type de t�che. Le redressement se r�duit � l'estimation de l'inclinaison du texte, une m�thode bas�e sur des histogrammes convient comme celle expliqu�e au paragraphe~\ref{image_seg_line} ou celle du paragraphe~\ref{image_redressement_sobel}. La plupart de ces pr�traitements sont d�crits sommairement dans~\citeindex{Yanikoglu1998}.
            
L'objectif avou� de cette partie est la conception d'une segmentation en graph�mes, c'est-�-dire le d�coupage de l'image d'un mot en une succession d'images correspondant � ses lettres ou � des morceaux de ses lettres qui seront utilis�s plus tard par des mod�les de reconnaissance de l'�criture. C'est un traitement souvent complexe et rarement parfait. Segmentation et reconnaissance sont encore deux �tapes distinctes et ceci explique pourquoi ce traitement inclut g�n�ralement une multitude de cas particuliers (voir~\citeindex{Lecolinet1991}, \citeindex{Simon1992}). La figure~\ref{image_grapheme_erreur} r�sume les faiblesses d'un algorithme de segmentation en graph�mes. Ce traitement produit des erreurs quelle que soit la m�thode choisie car il est des configurations qui n�cessitent la reconnaissance des lettres � segmenter afin d'�tre tranch�es comme la lettre "m" qui se confond avec le couple "rn".
        
        
            \begin{figure}[t]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=8cm, width=16cm]
        {\filext{../image/image/failure}}\end{array}$}$$
        \caption{      Erreurs de segmentation en graph�mes pour un algorithme (voir~\citeindexfig{Baret1991}) 
                                qui s'appuie 
                                essentiellement sur le squelette. Cette op�ration est erronn�e dans environ 10\% des cas.
                                Comment segmenter les deux premi�res lettres du mot "souris" ou "chat" alors que, dans ces
                                deux cas, ce sont presque deux boucles qui poss�dent une paroi commune~? Ces configurations
                                sont difficiles � segmenter car les lettres sont souvent �crites de mani�re enchev�tr�e
                                comme les deux "t" cons�cutifs, les lettres � liaisons hautes (b,o,v,w).}
        \label{image_grapheme_erreur}
            \end{figure}
            
\indexfrr{liaison}{haute}            
                                
L'algorithme utilis� pour d�couper les mots de la figure~\ref{image_grapheme_erreur} segmente mal les couples de lettres � liaison haute comme "oi" contrairement au couple "da" pour lequel, il y a tr�s peu d'erreurs. Il n'est pas �vident de juger de l'efficacit� d'un algorithme de segmentation en graph�mes, le r�sultat peut �tre d�cevant pour l'\oe il humain et n�anmoins �tre performant s'il est appari� � des mod�les de reconnaissance qui peuvent par exemple mod�liser ses erreurs (voir paragraphe~\ref{hmm_bi_lettre}, page~\pageref{hmm_bi_lettre}). 

Les paragraphes qui suivent se proposent de d�crire diff�rentes m�thodes de segmentations (lignes, mots, graph�mes) qui permettront de r�soudre le probl�me de reconnaissance de mots-cl� dans un paragraphe manuscrit. Il y aura peu d'�valuation de performances car il est difficile de juger la qualit� d'un traitement d'image autrement qu'en observant. La seule sanction est le taux de reconnaissance~: combien d'images ont-elles �t� bien d�crypt�es~? Et dans le cas d'une am�lioration des performances, on peut se demander si celles-ci sont dues � une am�lioration de la segmentation en graph�mes ou � une meilleure mod�lisation de cette derni�re par des mod�les probabilistes.

L'objectif de cette partie n'est donc pas d'am�liorer une segmentation graph�me existante (celle developp�e dans~\citeindex{Baret1991}) mais d'en proposer une autre afin d'obtenir deux cha�nes de reconnaissance suffisamment diff�rentes afin que leurs r�sultats soient si possible corr�l�s pour des images de bonne qualit� mais divergents pour des images de qualit� moyenne.







%-------------------------------------------------------------------------------------------------------------
\section{Apprentissage d'une segmentation}
%-------------------------------------------------------------------------------------------------------------
\label{image_apprentissage_segmentation}
\indexfrr{apprentissage}{segmentation}
\indexfr{Vorono�}
\indexfr{diagramme de Vorono�}
\indexfr{composante connexe}
\indexfr{connexit�}
\indexfr{squelette}

La segmentation en graph�mes pr�sent�e par la suite (paragraphe~\ref{image_choix_segmentation}) s'appuie sur de nombreux seuils fix�s "manuellement", ajust�s lors de la visualisation du r�sultat sur quelques images. Ces heuristiques interviennent lors de la segmentation d'une mani�re qui rend impossible une estimation autre qu'un t�tonnement progressif. Une segmentation pouvant �tre apprise a l'avantage de pouvoir �tre modifi�e en utilisant les r�sultats de la reconnaissance. Le second objectif vis� est une adaptation plus facile lorsque les documents � traiter changent. De plus, il serait possible d'envisager une boucle alternant les apprentissages de la reconnaissance et de la segmentation automatique. 




\subsection{Principe}


Cette id�e s'appuie sur les diagrammes de Vorono� qui proposent un maillage d'une image (figure~\ref{image_voronoi1}). L'image est d'abord d�crite par ses composantes connexes puis r�duite � l'�tat de squelette\seeannex{annexe_squelettisation}{squelettisation}. Ce squelette est ensuite d�coup� de mani�re � ce que les morceaux ainsi form�s soient coh�rents avec la segmentation d�sir�e. En r�sum�, aucun des morceaux obtenus ne doit appartenir � deux zones diff�rentes (voir~\ref{image_voronoi1}).

            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{ccc}
        \includegraphics[height=3.5cm, width=5cm] {\filext{../image/image/voronoi0}} & & 
        \includegraphics[height=3.5cm, width=5cm] {\filext{../image/image/voronoi1}}
        \end{array}$}$$
        \caption{    Diagramme de Vorono� utilis� pour une segmentation en lignes~: l'image de gauche repr�sente la 
                            segmentation � apprendre, les lignes fonc�es de l'image de droite indiquent les fronti�res du 
                            diagramme de Vorono� correspondant le mieux aux fronti�res entre les zones 
                            de la segmentation d�sir�e.}
        \label{image_voronoi1}
            \end{figure}

La segmentation en lignes d'une image telle que celle de la figure~\ref{image_voronoi1} devient un probl�me de classification en deux classes~: chaque segment du diagramme de Vorono� est une fronti�re entre deux zones � partager ou ne l'est pas. Comme le montre la figure~\ref{image_voronoi_local}, la classification d'un segment peut int�grer des informations relatives aux segments connect�s aux deux extr�mit�s ainsi que des caract�ristiques sur la forme du texte dans le voisinage de ce segment. L'objectif est la recherche d'une fonction du type~:

            \begin{eqnarray}
            f : S \times S^S_1 \times S^S_2 \times F^S_1 \times F^S_2 \longrightarrow \cro{0,1}
            \label{image_voronoi_f}
            \end{eqnarray}
        
            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{ccc}
        \includegraphics[height=3cm, width=3cm] {\filext{../image/image/voronoi10}} &&
        \includegraphics[height=3cm, width=3cm] {\filext{../image/image/voronoi11}}
        \end{array}$}$$
        \caption{    Voisinage d'un segment du diagramme de Vorono�~: tout segment 
                            est connect� � d'autres segments � ses 
                            deux extr�mit�s et il s�pare deux zones contenant chacune une petite partie 
                            du texte que contient l'image.}
        \label{image_voronoi_local}
            \end{figure}
            
$S$ est vecteur caract�risant le segment � classer, $S^S_1$ et $S^S_2$ sont deux vecteurs de m�me dimension caract�risant les vecteurs connect�s � $S$ � chacune de ses deux extr�mit�s, $F^S_1$ et $F^S_2$ sont deux vecteurs caract�risant la forme du contenu des deux zones de textes que $S$ s�pare (figure~\ref{image_voronoi_local}). 
            



\subsection{Exp�rimentations}


Dans un premier temps, la fonction $f$ (\ref{image_voronoi_f}) a �t� estim�e � l'aide d'un r�seau de neurones classifieur\seeannex{subsection_classifieur}{classifieur}. Les vecteurs $S$, $F^S_1$, $F^S_2$ contenaient des informations relatives � la longueur du segment, sa courbure, son inclinaison, la distance du segment au texte. Les vecteurs $S^S_1$ et $S^S_2$ contenaient des moyennes des m�mes informations. L'estimation de la fonction $f$ a conduit au r�sultat figure~\ref{image_voronoi2} avec un pourcentage de bonne classification proche de 95\%.

            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=5cm, width=7cm]
        {\filext{../image/image/voronoi2}}\end{array}$}$$
        \caption{    Diagramme de Vorono� utilis� pour une segmentation en lignes~: 
                            le r�sultat laisse appara�tre des lignes
                            en pointill�. Dans 95\% des cas, les segments de Vorono� sont bien class�s.}
        \label{image_voronoi2}
            \end{figure}
            
M�me si le pourcentage d'erreur est faible, il m�ne � l'apparition de lignes "trou�es" qui sugg�re soit l'abandon de la m�thode, soit son perfectionnement selon deux directions qui sont la cr�ation d'un processus it�ratif permettant de faire �voluer la probabilit� d'un segment en fonction de ses voisins et un post-traitement dont l'objectif est l'�limination des "trous". La premi�re direction passe par la construction d'une suite $\pa{p_t}$ pour chaque segment de telle sorte que~:

            \begin{eqnarray*}
            p^S_0 &=& f\pa{S, S^S_1, S^S_2, F^S_1, F^S_2} \\
            \forall t \supegal 0, \; p^S_{t+1} &=& g\pa{p^S_t, S, p^{S_1}_t, S^S_1, p^{S_2}_t, S^S_2, F^S_1, F^S_2}
            \end{eqnarray*}
            
Le processus s'arr�te lorsque la suite $\pa{p^S_t}_{t\supegal 0}$ converge pour chaque segment $S$. Il reste � estimer la fonction $g$. Le nombre d'it�rations n�cessaires � la convergence d'un tel syst�me demeure inconnu. La seconde direction correspond en quelque sorte au nettoyage des r�sultats retourn�s par la fonction $f$ (ou son prolongement $g$), les lignes presque achev�es sont compl�t�es, les bouts de lignes ne menant � rien sont effac�es. 

Cette m�thode s'appuie sur un diagramme de Vorono� qui peut s'av�rer instable lorsque l'image est de mauvaise qualit�, lorsque quelques pixels �gar�s cr�ent des r�gions artificielles. Les diagrammes de Vorono� flous (\citeindex{Zhao2000}) seraient peut-�tre une alternative � ce probl�me. De plus, la convergence de l'ensemble n'est pas assur�e et peut d�boucher sur des temps de traitements longs inconvenants pour des applications telles que la reconnaissance de l'�criture. Aucun des deux prolongements n'a �t� �tudi�.
            
            





\subsection{Extension au probl�me de nettoyage}

\indexfr{nettoyage}
\indexfr{Vorono�}

Le nettoyage est un probl�me dual du pr�c�dent puisqu'au lieu de classer les segments du diagramme de Vorono�, il suffit de classer les zones d�limit�es par ce diagramme en deux classes~: zone � nettoyer ou non. L'avantage du diagramme de Vorono� est de proposer un voisinage (figure~\ref{image_voronoi_local}) pour chaque petite r�gion. Une application pratique est la suppression d'une ligne qui sert de guide pour l'�criture comme celle montr�e figure~\ref{image_global}. L'int�r�t de la m�thode r�side toujours dans son apprentissage et son inconv�nient dans la forte sensibilit� du diagramme de Vorono� aux ruptures de connexit�.







\subsection{Diagramme de Kohonen}
\indexfr{Kohonen}
\indexfr{relaxation probabiliste}
\indexfr{champs de Markov}
\indexfrr{Markov}{champs}
\indexfrr{segmentation}{ligne}
\indexfrr{segmentation}{mot}

Outre le fait que le diagramme de Vorono� est tr�s sensible au bruit, pour une r�gion donn�e, le nombre de voisins est tr�s variable, il est alors n�cessaire de r�sumer l'information contenue par ce voisinage. On utilise une carte de Kohonen dont la structure est celle d'un quadrillage. Les pixels noirs attirent les neurones qui �tirent les ar�tes qui les relient comme le montre la figure~\ref{image_koho_lines}a. Les ar�tes les plus grandes forment des ponts entre deux r�gions, un simple seuillage (figure~\ref{image_koho_lines}b) permet presque d'isoler les mots. L'avantage de cette nouvelle structure est son voisinage de taille fixe, quelle que soit la d�formation du treillis de Kohonen, chaque neurone conservera quatre voisins, il est alors possible d'utiliser des algorithmes (relaxation probabiliste, champs de Markov) permettant de classer les ar�tes en deux cat�gories~: ar�te � l'int�rieur d'une r�gion, ar�te reliant deux r�gions � segmenter.



            \begin{figure}[ht]
        $$\begin{tabular}{|c|c|}\hline
        \includegraphics[height=4cm, width=6cm]{\filext{../image/image/koholine1}} &
        \includegraphics[height=4cm, width=6cm]{\filext{../image/image/koholine2}} \\
        $(a)$ & $(b)$ 
        \\ \hline \end{tabular}$$
        \caption{    Treillis de Kohonen appliqu� � la segmentation en ligne, l'image $(a)$ 
                            pr�sente le r�sultat apr�s convergence
                            des neurones, l'image $(b)$ repr�sente le m�me treillis dont les ar�tes les 
                            plus grandes ont �t� �t�es. Il reste dans le meilleur des cas des assemblages connexes
                            recouvrant l'image d'un des mots.}
        \label{image_koho_lines}
            \end{figure}


L'inconv�nient de cette m�thode r�side dans l'obtention du treillis final de Kohonen, la convergence est gourmande en temps de calcul pour de grandes images. C'est pour cela que cette id�e n'a pas �t� poursuivie. En revanche, ce temps de calcul devient acceptable si la dimension de l'image est celle d'un mot, cette m�thode pourrait donc �tre utilis�e pour apprendre une segmentation en graph�mes. 

Cet apprentissage n�cessite malgr� tout de nombreuses images pour lesquelles la segmentation en graph�mes doit �tre connue. L'obtention d'une telle base de donn�es peut �tre manuelle mais ce travail est long ou effectu� � partir d'un syst�me de reconnaissance d�j� existant mais contenant des erreurs. Les mots les mieux reconnus sont alors d�coup�s en graph�mes ou caract�res selon l'usage d�sir� puis serviront d'apprentissage. Cette direction n'a pour le moment pas �t� envisag�e, une autre permettant de mod�liser des erreurs de segmentation en graph�mes lui a �t� pr�f�r�e dans un premier temps (voir paragraphe~\ref{hmm_bi_lettre}, page~\pageref{hmm_bi_lettre}). \indexfrr{segmentation}{graph�me} \indexfr{graph�me} Cette mod�lisation permet d'ailleurs une meilleure appr�ciation de la segmentation en graph�mes.













%-------------------------------------------------------------------------------------------------------------
\section{Segmentation en lignes}
%-------------------------------------------------------------------------------------------------------------
\label{image_seg_line}
\indexfrr{segmentation}{ligne}
\indexfr{histogramme}

Lors de la scannerisation d'un document, il peut arriver que celui-ci soit inclin� (figure~\ref{image_segline_direction}). La premi�re �tape consiste donc � redresser une image de telle sorte que les lignes qui la composent soient horizontales. Ce paragraphe aborde diverses solutions existantes et r�sume les r�sultats �nonc�s dans~\citeindex{Dupr�2000}.






\subsection{Redressement de l'inclinaison de l'image}
\indexfr{inclinaison}


De nombreuses m�thodes sont utilis�es pour d�tecter l'inclinaison des lignes, leurs robustesses variant avec la difficult� du probl�me. L'article~\citeindex{Cao2003} par exemple propose une m�thode plus adapt�e aux textes imprim�s. Les composantes connexes (des lettres principalement) sont toutes d�crites par un point situ� au milieu du bord inf�rieur de leurs bo�tes englobantes. Par la suite, ces points sont regroup�s et class�s en lignes. Une r�gression lin�aire sur chacune des lignes termine l'estimation de l'inclinaison de l'image. \indexfr{cha�ne de plus proches voisins} Une autre m�thode pr�sent�e dans~\citeindex{Lu2003} utilise des cha�nes de plus proches voisins (ou nearest neighbors chains), celles-ci sont constitu�es par l'appariement de voisins. L'inclinaison est mesur�e sur chacune des cha�nes qui doivent �tre suffisamment longues pour une mesure pr�cise mais pas trop pour �viter le regroupement de voisins trop �loign�s n'appartenant pas � la m�me ligne de texte. \indexfrr{Hough}{transform�e de ...} La transform�e de Hough est aussi une m�thode tr�s utilis�e (voir~\citeindex{Pal1996}), chaque petit segment de l'image permet d'estimer les coefficients du vecteur directeur de la droite qui le soutient. La direction de l'inclinaison du document correspond aux coefficients les plus repr�sent�s. Les histogrammes permettent �galement d'estimer cette inclinaison (voir~\citeindex{Bloomberg1995}) comme de segmenter l'image redress�e en lignes (voir~\citeindex{Gatos1997}, \citeindex{Pal2001}). C'est cette approche qui est pr�sent�e ici.




            \begin{xdefinition}{histogramme}
            \indexfr{histogramme}
            
            L'histogramme d'une image selon une direction $\alpha$ est une projection de cette image 
            sur une droite parall�lement � une droite de vecteur directeur $d=\pa{\begin{subarray}{c} 1 
            \\ tan \alpha \end{subarray}}$. Concr�tement, si $I$ est une image de dimension $\pa{X,Y}$, un
            histogramme est un vecteur dont chaque �l�ment contient le nombre de pixels noirs sur une ligne de
            direction~$d$ trac�e avec un algorithme comme celui de~\citeindex{Bresenham1965} (voir
            �galement~\citeindex{Bresenham1977}).
            
            \end{xdefinition}



La qualit� de l'histogramme ou sa pertinence est estim�e par son entropie.



        \begin{xdefinition}{entropie d'un histogramme}
        \indexfr{entropie d'un histogramme}
        
        Soit $H = \vecteur{h_1}{h_n}$, on d�finit le vecteur d�fini par $H' = \vecteur{p_1}{p_n}$~:
        
                    $$
                    \forall i \in \intervalle{1}{n}, \; p_i =  \frac{h_i} { \summy{k=1}{n} \, h_k }
                    $$
        
        L'entropie de l'histogramme $H$ est le nombre suivant calcul� sur l'histogramme $H'$~:
        
                    \begin{eqnarray}
                    E\pa{H} &=& E\pa{H'} = \summy{i=1}{n} \; p_i \, \ln p_i
                    \end{eqnarray}
        
        \end{xdefinition}

\indexfr{redressement}\indexfr{glissement de pixels}

La direction la plus probable est celle qui maximise l'entropie (voir~\citeindex{C�t�1997}). Graphiquement, l'histogramme d'entropie maximale est celui dont les extrema sont les plus marqu�s (voir figure~\ref{image_segline_direction}).
L'image est finalement redress�e de fa�on � ce que l'image ne contienne plus des lignes horizontales. Ce redressement peut tout simplement �tre effectu� par un glissement des colonnes de pixels de l'image les unes par rapport aux autres. 


            \begin{figure}[t]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=4cm, width=14cm]
        {\filext{../image/image/segline1}}\end{array}$}$$
        \caption{    Segmentation en lignes~: recherche de la meilleure orientation, celle-ci accentue 
                            le plus possible les extrema.}
        \label{image_segline_direction}
            \end{figure}


\indexfr{Radon}\indexfrr{transform�e}{Radon}\indexfr{Hough}\indexfrr{transform�e}{Hough}
Il existe des m�thodes plus r�centes comme par exemple celle d�crite dans \citeindex{Kapoor2004}. A partir d'une transform�e de Radon de l'image et d'une transform�e de Hough. Cette m�thode est plus souple que la pr�c�dente. La m�thode des histogrammes d�termine l'orientation la plus probable dans un ensemble discret de solutions possibles. L'article \citeindex{Kapoor2004} d�termine directement cette meilleure orientation.




\subsection{Segmentation en lignes}\label{section_segmentation_ligne}
\indexfrr{segmentation}{ligne}


L'histogramme obtenu figure~\ref{image_segline_direction} est bruit�. Afin de diminuer l'importance de ce bruit, l'histogramme est liss� par la m�thode des moyennes mobiles. Selon les probl�mes, la taille de cette moyenne est plus ou moins grande. Soit $H_l = \vecteur{l_1}{l_n}$ l'histogramme liss�, il est donc obtenu � partir de $H$ comme suit~:


            \begin{eqnarray}
            \begin{array}{rrcl}
            \forall i \in \intervalle{w+1}{n-w-1},     \; &     l_i &=& \dfrac{1}{2w+1} \, \summy{k=-w}{+w} \, h_{i+k} \\
            \forall i \in \intervalle{1}{w},                 \; &     l_i &=& \dfrac{1}{i+w} \, \summy{k=1}{i+w} \, h_k \\
            \forall i \in \intervalle{n-w}{n},             \; &     l_i &=& \dfrac{1}{n-i+ w + 1} \, \summy{k=i-w}{n} \, h_k 
            \end{array}
            \label{image_lissage_equation}
            \end{eqnarray}


Les maxima locaux indiquent la position des lignes, les minima locaux la position des fronti�res entre lignes. On d�finit pour chaque ligne les minima $\pa{m_i^x}_i$ et les maxima $\pa{M_i^x}_i$~:


            $$
            \begin{array}{rcl}
            \forall i, \; m_i^x = \left\{ \begin{array}{l}
                                                                        1 \text{ si } l_i = \min \acc { l_k \sac l-x \infegal k \infegal l+x } \\
                                                                        0 \text{ sinon}
                                                                    \end{array} \right. \\
            \forall i, \; M_i^x = \left\{ \begin{array}{l}
                                                                        1 \text{ si } l_i = \max \acc { l_k \sac l-x \infegal k \infegal l+x } \\
                                                                        0 \text{ sinon}
                                                                    \end{array} \right.
            \end{array}
            $$


La figure~\ref{image_segline_extrema} montre que bien souvent le nombre d'extrema d�tect�s est sup�rieur au nombre r�el d'extrema. Une �tude sur quelques dizaines d'images a permis d'�liminer les cas de mauvaises d�tections les plus courants~:

\begin{enumerate}
\indexfr{petit palier}
\item \textit{Le petit palier}~: ce cas se pr�sente le plus souvent lorsqu'une ou plusieurs majuscules font partie de la ligne de texte. Le dessin de ces lettres contient des traits horizontaux trac�s au-dessus de la ligne des minuscules. Une barre de "F" bien marqu�e peut entra�ner de mauvaises segmentations.
\indexfr{petit extremum}
\item \textit{Le petit extremum}~: lorsque les mots ne sont pas tout-�-fait bien align�s sur une m�me horizontale, les extrema sont plus diffus, il faut alors regrouper plusieurs maxima ensemble.
\end{enumerate}


Deux r�gles permettent l'�limination de ces mauvaises d�tections~:

            \begin{enumerate}
            \item Soit $\acc{e_i \sac 1 \infegal i \infegal 4}$ quatre extrema cons�cutifs, alors~:
                                \begin{eqnarray}
                                \abs{e_2 - e_3} \infegal \beta \abs{e_1 - e_4} \Longrightarrow 
                                \acc{e_2, \, e_3} \text{ doivent �tre �limin�s.} 
                                \label{image_ligne_critere_palier_1}
                                \end{eqnarray}
            \item Soit $e_2$ un minimum et $e_1$ et $e_3$ les extrema qui l'entourent, alors~:
                                \begin{eqnarray}
                                e_2 \infegal \gamma \min\acc{e_1,e_3} \Longrightarrow 
                                \acc{e_2, \, e_1 \text{ ou } e_3} \text{ doivent �tre �limin�s.} 
                                \label{image_ligne_critere_palier_2}
                                \end{eqnarray}
            \end{enumerate}
    
Ce processus est illustr� par la figure~\ref{image_segline_extrema}. Les valeurs int�ressantes pour les quatre param�tres $w$, $x$, $\beta$, $\gamma$ sont~:

            $$
            \begin{array}{ccccccc}
            w &=& 4  \text{ pixels}     &&    \beta     &=& 0,2 \\
            x &=& 4  \text{ pixels}      &&    \gamma     &=& 0,5 
            \end{array}
            $$



            \begin{figure}[t]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=6cm, width=12cm]
        {\filext{../image/image/segline2}}\end{array}$}$$
        \caption{    Segmentation en lignes~: recherche des bons extrema. Les extrema trop proches v�rifiant les
                            crit�res~(\ref{image_ligne_critere_palier_1}) et~(\ref{image_ligne_critere_palier_2})
                            ne sont pas pris en compte.}
        \label{image_segline_extrema}
            \end{figure}



Le processus de suppression des "faux" extrema n�cessite plusieurs it�rations, � chacune d'elle, le plus petit palier est isol� et supprim�, ensuite, l'op�ration est r�p�t�e pour les petits extrema. Le processus s'arr�te lorsqu'il ne peut plus rien supprimer, autrement dit, lorsqu'aucun petit palier et aucun petit extremum n'a pu �tre trouv�.





\subsection{Traitements des lignes enchev�tr�es}

\indexfrr{ligne}{enchev�tr�e}



C'est la derni�re �tape avant la reconnaissance du contenu des lignes. L'�tude de l'histogramme a permis d'encadrer chaque ligne par un rectangle dont d�passent certaines grandes lettres ascendants et/ou descendants comme les "j" ou les "p". Le module de reconnaissance des mots est bas� sur une extraction de graph�mes utilisant la connexit� du dessin des lettres.


            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=2cm, width=4cm]
        {\filext{../image/image/segline3}}\end{array}$}$$
        \caption{Segmentation en lignes~: connexit�}
        \label{image_segline_connex}
            \end{figure}



En partant de la m�me id�e, on va supposer que le "j" de "Lajoie" (figure~\ref{image_segline_connex}) est form� d'une seule composante connexe. La segmentation en lignes s'ach�ve donc par le recollement des morceaux d'une m�me lettre �gar�s des deux c�t�s d'une fronti�re s�parant deux lignes. Le principe est le suivant~:

            \begin{enumerate}
            \item On parcourt la fronti�re entre deux lignes jusqu'� ce qu'on intercepte une lettre.
            \item On parcourt le contour ext�rieur du morceau situ� au-dessus, si lors de ce parcours, 
                            on revient � la m�me fronti�re sans en rencontrer aucune autre, alors ce morceau de 
                            lettre est consid�r� comme �tant du mauvais c�t�.
            \item On parcourt le contour ext�rieur du morceau situ� au-dessous, si lors de ce parcours, 
                            on revient � la m�me fronti�re sans en rencontrer aucune autre, alors ce morceau de 
                            lettre est consid�r� comme �tant du mauvais c�t�.
            \item Si un seul des deux morceaux est du mauvais c�t� alors ce morceau est remis dans la bonne ligne, 
                            sinon on ne fait rien.
            \item On continue le parcours de la fronti�re au cas o� d'autres lettres intercepteraient celle-ci.
            \end{enumerate}

Dor�navant, l'extraction des lignes est termin�e. Cette m�thode fonctionne efficacement sur des adresses mais poss�de quelques �cueils r�currents (figure~\ref{image_segline_bad}).


            \begin{figure}[t]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=12cm, width=8cm]
        {\filext{../image/image/segline_bad}}\end{array}$}$$
        \caption{Segmentation en lignes~: exemples qui ne marchent pas.}
        \label{image_segline_bad}
            \end{figure}








\subsection{Segmentation � partir d'un graphe}
\indexfr{graphe}
\indexfrr{segmentation}{ligne}


L'article \citeindex{Abuhaiba1996} propose une autre alternative, une m�thode de segmentation en lignes bas�e sur un graphe $k$-connexe (voir figure~\ref{image_graphe_distance_segment_fig}). L'image d'un paragraphe est d'abord squelettis�e puis vectoris�e\seeannex{squelette_vectorisation_Abuhaiba1996}{squelettisation}. Chaque arc ainsi obtenu est ensuite reli� � $k$-plus proches voisins ordonn�s selon la distance (\ref{image_graphe_distance_segment}). Soient deux segments $S_1$ et $S_2$, la distance $d\pa{S_1,S_2}$ est d�finie par~:


            \begin{eqnarray}
            d_x\pa{S_1,S_2}     &=&        \underset{\pa{u,v} \in S_1 \times S_2} {\min } \; \abs{ u_x - v_x } \nonumber \\
            d_y\pa{S_1,S_2}     &=&        \underset{\pa{u,v} \in S_1 \times S_2} {\min } \; \abs{ u_y - v_y } \nonumber \\
            d\pa{S_1,S_2}            &=&        \cro { 1 + \gamma \, \pa{ \frac{\pi}{2} }^{-1}  \arctan \frac{ d_y\pa{S_1,S_2} } {d_x\pa{S_1,S_2} } }
                                                            \; \sqrt { d_x\pa{S_1,S_2} ^2 + d_y\pa{S_1,S_2} ^ 2} 
                        \label{image_graphe_distance_segment}
            \end{eqnarray}


            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=3cm, width=6cm]
        {\filext{../image/image/abusl}}\end{array}$}$$
        \caption{Segmentation en lignes en recherchant l'arbre de poids minimal. L'axe vertical 
                            sur la droite de l'image est ajout� de fa�on � relier toutes les lignes entre elles, figure 
                            extraite de \citeindexfig{Abuhaiba1996}.}
        \label{image_graphe_distance_segment_fig}
            \end{figure}
            
\indexfr{Kruskal}
\indexfrr{arbre}{poids minimal}
            
Le param�tre $\gamma$ est choisi de telle sorte que deux segments appartenant � la m�me ligne soient plus proches que deux segments situ�s sur deux lignes cons�cutives. Chaque segment est donc reli� � ses $k$ plus proches voisins par un arc dont le poids est la distance (\ref{image_graphe_distance_segment}). A ce graphe est ajout� un axe constitu� de petits segments tr�s peu �loign�s de sorte qu'une connexion � cet axe est beaucoup moins co�teuse que tout autre connexion. L'arbre est ensuite r�duit � un arbre de poids minimal en appliquant l'algorithme de Kruskal (voir \citeindex{Kruskal1956}). La segmentation en lignes s'ach�ve par la d�tection de toutes les liaisons � l'axe virtuel non d�truit par l'algortihme de Kruskal.









%-------------------------------------------------------------------------------------------------------------
\section{Pr�traitements de l'image}
%-------------------------------------------------------------------------------------------------------------
\indexfr{pr�traitement de l'image}

Ce paragraphe regroupe ensemble diff�rents pr�traitements pr�c�dant une segmentation en graph�mes, il regroupe le redressement d'image ou l'estimation de diff�rents param�tres comme la largeur moyenne d'une lettre, son �paisseur moyenne. Contrairement � la segmentation en lignes, ces m�thodes sont particuli�res � l'�criture romaine. Les caract�res chinois par exemple pr�sentent des "imperfections" qui leur sont propres et qui n�cessitent des traitements diff�rents.




\subsection{Redressement de l'image}
\label{image_redressement_sobel}
\indexfrr{filtre}{Sobel}
\indexfr{Sobel}
\indexfr{convolution}
\indexfrr{gradient}{image}
\indexfr{inclinaison}

Une fois les lignes d'un paragraphe extraites, il est parfois utile de redresser son image lorsque le scripteur a �crit "pench�". Le rapport~\citeindex{Slavik2000} compare les performances en reconnaissance sur des images redress�es ou non et montre l'apport substantiel des m�thodes de pr�traitement d'image. Les m�thodes de redressement diff�rent bien s�r par leurs m�thodes d'estimation de l'inclinaison mais aussi par les r�gions de l'image utilis�es pour effectuer cette estimation. 

\indexfr{ascendant}
\indexfr{descendant}
L'inclinaison d'un mot est surtout visible pour les lettres poss�dant des ascendants et des descendants et c'est a priori cette partie de l'image qui doit �tre utilis�e pour l'estimation de l'inclinaison comme le sugg�re la m�thode de~\citeindex{Bozinovic1989} (voir figure~\ref{image_slant_correction_bozinovic}) qui s�lectionne les ascendants et descendants situ�s dans les parties sup�rieure et inf�rieure de l'image. 


            \begin{figure}[ht]
        $$\begin{tabular}{|c|} \hline
        \includegraphics[height=3cm, width=6cm]{\filext{../image/image/slantst}}  \\ \hline
        \end{tabular}
        $$
        \caption{    M�thode de Bozinovic et Srihari (voir~\citeindexfig{Bozinovic1989}), figure exraite 
                            de~\citeindexfig{Vinciarelli2000}. Le principe de cette m�thode consiste � estimer 
                            l'orientation    du texte en ne consid�rant que les ascendants ou descendants suffisamment
                            grands compris entre deux lignes verticales reli�es aux bords sup�rieur et inf�rieur de l'image.}
        \label{image_slant_correction_bozinovic}
            \indexfr{ascendant}
            \indexfr{descendant}
            \end{figure}


La m�thode d�crite dans~\citeindex{Slavik2000} quant � elle mesure l'inclinaison de chaque bord lat�ral des diff�rentes composantes connexes puis en fait la moyenne pond�r�e par la longueur des segments obtenus. \citeindex{Kim1997} et \citeindex{Knerr1997} propose une estimation fond�e sur les contours. Si $n_+$ et $n_-$ d�signent le nombre de d�placements positifs et n�gatifs selon l'axe des abscisses, et $n_v$ le nombre de d�placements verticaux, l'angle~$\theta$ de l'inclinaison est obtenu � partir de l'expression de sa tangente~: $\tan \theta = \frac{n_+ - n_-}{n_v+n_++n_-}$. La m�thode de \citeindex{Vinciarelli2000} utilise des histogrammes. Pour diff�rentes valeurs d'angles $\alpha$, on calcule le nombre $H_{\alpha}\pa{x} = \frac{h_{\alpha}\pa{x}}{\Delta y_{\alpha}\pa{x}}$, o� $h_{\alpha}\pa{x}$ est le nombre de pixels sur la colonne $x$ et $\Delta y_{\alpha}\pa{x}$ la distance qui s�pare les pixels noirs situ�s le plus haut et le plus bas. $H_{\alpha}\pa{x}$ vaut $1$ uniquement si la colonne est constitu�e d'un seul segment. Ensuite, pour chaque valeur d'angle, on calcule $S\pa{\alpha} = \sum_{x, H_{\alpha}\pa{x} = 1} h_{\alpha}^2\pa{x}$. L'inclinaison du mot est alors l'angle $\alpha$ qui maximise $S\pa{\alpha}$. Toutes ces m�thodes sont mieux adapt�es � la d�tection de l'inclinaison de l'�criture romaine, d'autres types d'�criture, comme le montre l'article \citeindex{You2003} dans le cas de l'�criture cor�enne, n�cessitent des d�veloppements plus sp�cifiques. \indexfrr{�criture}{cor�enne}


La m�thode propos�e ici s'inspire de celle d�crite dans~\citeindex{Yanikoglu1998} et s'av�re plus simple que l'estimation d'histogrammes. Elle donne les m�mes r�sultats qu'une m�thode estimant l'inclinaison � partir du contour sans pour autant chercher � les obtenir. Les deux filtres de Sobel (\ref{image_eq_sobel_filtre}) (voir~\citeindex{Prewitt1970}) permettent de retrouver en chaque point de l'image la direction du gradient. 


            \begin{eqnarray}
            F_x = 
            \begin{array}{|c|c|c|} \hline
            -1 & 0 & 1 \\ \hline
            -2 & 0 & 2 \\ \hline
            -1 & 0 & 1 \\ \hline
            \end{array}
            &
            \text{ et }
            &
            F_y =
            \begin{array}{|c|c|c|} \hline
             1 & 2 & 1 \\ \hline
             0 & 0 & 0 \\ \hline
            -1 & -2 & -1 \\ \hline
            \end{array}
            \label{image_eq_sobel_filtre}
            \end{eqnarray}


Soit $I$ l'image d'un mot, On note $G_x = I * F_x$ et $G_y = I * F_y$ les produits de convolution de l'image par les deux filtres d�crits en (\ref{image_eq_sobel_filtre}). Il est alors possible de d�terminer en un point $\pa{x,y}$ la direction du gradient de la fa�on suivante en s'arrangeant pour que celle-ci appartienne � l'intervalle $\left[0,\pi \right[$~:

            \begin{eqnarray}
            \theta\pa{x,y} &=& \arctan\cro{\dfrac{G_y\pa{x,y}}{G_x\pa{x,y}}} 
            \in \left[0,\pi \right[
            \end{eqnarray}


Cet intervalle est ensuite divis� en $n$ sous-intervalles de longueur identique afin de construire l'histogramme $\pa{\alpha_i}_{1 \infegal i \infegal n}$ suivant~:


        \begin{eqnarray}
        \forall i \in \ensemble{1}{n}, \; \alpha_i &=&  card 
        \acc{ \pa{x,y} \in I \sac \theta\pa{x,y} \in \left[0,\pi \right[ } \nonumber
        \end{eqnarray}


            \begin{figure}[ht]
        $$\begin{array}{|c|c|} \hline
        \includegraphics[height=1.1cm, width=2.5cm]{\filext{../image/image/histo_word}}   &
        \includegraphics[height=2cm, width=5cm]{\filext{../image/image/histo_incl}}   \\ \hline
        \end{array}
        $$
        \caption{    R�partition de la direction du gradient pour une image de mot en neuf intervalles
                            d'angle (les angles sont en radians).
                            Le pic de l'histogramme est d�cal� par rapport � $\pi/2$.  }
        \label{image_gradient_direction_histogramme}
            \end{figure}


Un exemple d'un tel histogramme est donn� par la figure~\ref{image_gradient_direction_histogramme}. Il montre un pic principal qui correspond � l'orientation des lettres hautes (t,l,...). Toutefois, � partir de quelques images, on a constat� que cet histogramme m�ne � une estimation moins pr�cise de la direction d'inclinaison qu'une moyenne sur l'ensemble des directions calcul�es en �vitant les directions proches de l'horizontale. On note $\hat{\theta}$ cette estimation~:

            \begin{eqnarray}
            \hat{\theta} &=&         \dfrac{1}{
                                                                \summyone{\pa{x,y}} \; 
                                                                \indicatrice{ \theta\pa{x,y} \in \cro{\frac{\pi}{8},\frac{7\pi}{8}}} } \;
                                                    \summyone{\pa{x,y}} \; \theta\pa{x,y} 
                                                    \indicatrice{ \theta\pa{x,y} \in \cro{\frac{\pi}{8},\frac{7\pi}{8}}}
                                \label{image_direction_estimation}
            \end{eqnarray}
            


L'image est ensuite redress�e en faisant glisser les lignes de pixels les unes sur les autres comme le montre la figure~\ref{image_gradient_direction_histogramme_correct}.


            \begin{figure}[ht]
        $$\begin{array}{|c|c|} \hline
        \includegraphics[height=1.1cm, width=2.5cm]{\filext{../image/image/histo_word}}   &
        \includegraphics[height=1.1cm, width=3cm]{\filext{../image/image/histo_wori}}   \\ \hline
        \end{array}$$
        \caption{    Correction de l'inclinaison de l'image effectu�e par un glissement des lignes 
                            les unes sur les autres. L'estimation de la direction par 
                            (\ref{image_direction_estimation}) donne 58 degr�s, 90 �tant la valeur pour
                            �criture non inclin�e.}
        \label{image_gradient_direction_histogramme_correct}
            \end{figure}











\subsection{Lissage du contour}

\indexfrr{lissage}{contour}
\indexfrr{contour}{lissage}
\label{image_lissage_contour__}

La correction de l'inclinaison se termine par la construction de l'image corrig�e qui est le r�sultat d'un glissement des lignes de pixels les unes par rapport aux autres. Cette m�thode simple a pourtant l'inconv�nient de produire des irr�gularit�s tout le long du contour des lettres (voir figure~\ref{image_lissage_contour_said}). Ces petits bruits peuvent alt�rer les r�sultats de la reconnaissance (voir~\citeindex{Slavik2000}). 

            \begin{figure}[ht]
        $$\begin{tabular}{|c|} \hline
        \includegraphics[height=3cm, width=3cm]{\filext{../image/image/smoothsaid}} \\ \hline
        \end{tabular}$$
        \caption{    Ces deux images proviennent de la barre du "d" 
                            de la figure~\ref{image_gradient_direction_histogramme_correct}. Le r�sultat obtenu
                            d� aux glissements des lignes les unes par rapport aux autres 
                            pr�sente de nombreuses irr�gularit�s qu'il serait pr�f�rable de gommer.
                            }
        \label{image_lissage_contour_said}
            \end{figure}

\indexfrr{point}{inflexion}

La m�thode propos�e dans~\citeindex{Slavik2000} s'appuie sur la m�me m�thode que celle qui permet d'obtenir le squelette d'une image\seeannex{annexe_squelettisation}{squelettisation}. Par l'application des masques de la figure~\ref{image_lissage_contour}, les lettres dont l'inclinaison a �t� corrig�e perdent peu � peu leurs petites rides. Le processus continue tant que l'image �volue. Cet algorithme a �t� utilis� pour lisser l'image de la figure~\ref{image_smooth_deslant} dont l'inclinaison a �t� corrig�e.
La figure~\ref{image_smooth_deslant}c montre le r�sultat obtenu gr�ce � cet algorithme de lissage utilisant les masques cit�s par la figure~\ref{image_lissage_contour}. Le r�sultat est satisfaisant, les lignes droites incluent n�anmoins de larges cr�neaux qu'il serait possible d'�laguer en �tudiant la convexit� du contour, en minimisant le nombre de ses points d'inflexion.




            \begin{figure}[t]
        $$\begin{tabular}{|c|} \hline
        \includegraphics[height=6cm, width=5cm]{\filext{../image/image/smoothbo}} \\ \hline
        \end{tabular}$$
        \caption{    Les configurations pixelliques ci-dessus permettent de lisser le contour apr�s que 
                            l'inclinaison d'un mot a �t� corrig�e. Cette figure est extraite de \citeindexfig{Slavik2000}
                            � laquelle il faut ajouter les configurations obtenues par rotation de celles pr�sent�es 
                            ci-dessus.}
        \label{image_lissage_contour}
            \end{figure}



            \begin{figure}[t]
            $$\begin{tabular}{|c|c|c|} \hline
            \includegraphics[height=3cm, width=4cm]{\filext{../image/image/imslant}} &
            \includegraphics[height=4cm, width=6cm]{\filext{../image/image/imslant_}} &
            \includegraphics[height=4cm, width=6cm]{\filext{../image/image/imslants}}  \\
            (a) & (b) & (c) \\ \hline
            \end{tabular}$$
            \caption{    L'inclinaison de l'image~(a) est corrig�e par la m�thode expos�e
                                au paragraphe~\ref{image_redressement_sobel} et donne l'image~(b). Les irr�gularit�s 
                                du contour sont ensuite corrig�es gr�ce � l'algorithme pr�sent� au 
                                paragraphe~\ref{image_lissage_contour__} et qui aboutit � l'image~(c).}
            \label{image_smooth_deslant}
            \end{figure}
            









\subsection{Lignes d'appui}
\label{image_ligne_appui}
\indexfrr{ligne}{appui}
\indexfrr{ligne}{base}
\indexfr{ascendant}\indexfr{descendant}

Les lignes d'appui encadrent la bande des minuscules et d�limitent les zones contenant les ascendants et descendants (voir figure~\ref{image_ligne_appui_fig}). Plusieurs m�thodes permettent de d�tecter ces lignes virtuelles mais toutes n�cessitent quelques lettres afin de retourner un r�sultat fiable. Il est par exemple impossible de distinguer un "o"~minuscule d'un "O"~majuscule si aucune autre lettre qui serait juxtapos�e ne vient aider la lecture. 

\indexfrr{Hough}{transform�e de ...}
L'article \citeindex{Wang1997} propose une m�thode utilisant ces m�mes extrema locaux du contour ext�rieur de l'image d'un mot mais les lignes d'appui sont estim�es globalement sur toute l'image � partir d'une transform�e de Hough. Comme les images sont suppos�es contenir deux lignes d'appui parall�les et proches, les r�sultats sont affin�s afin d'obtenir cette configuration.

Un autre article (\citeindex{Madhvanath1999}) sugg�re que l'estimation globale de la position de ces lignes m�ne fr�quemment � un r�sultat de mauvaise qualit� surtout si les lettres ne sont pas dispos�es sur une droite ou si les minuscules pr�sentent des tailles diff�rentes. La m�thode propos�e dans cet article s'appuie sur les extrema du contour de l'image d'un mot puis regroupe localement ces points en petits segments regroupant des points proches et presque align�s. L'ensemble de ces petits segments d�finit des lignes d'appui variables tout au long du mot.

Plusieurs histogrammes peuvent �tre utilis�s, �paisseurs des traits, nombre de transitions blanc-noir, projection des points du contour, celui-ci est souvent liss� par une moyenne mobile. En r�gle g�n�rale, la ligne d'appui basse est la plus fiable. Soit un histogramme $h=\vecteur{h_1}{h_N}$, o� $h_1$ correspond au bas de l'image et $h_i$ est la moyenne des longueurs des segments blancs de la ligne $i$. L'histogramme est liss� avec une moyenne mobile analogue � (\ref{image_lissage_equation}). On d�finit $l_b$ comme la ligne d'appui basse, $l_h$ la ligne d'appui haute, $l$ la ligne correspond au maximum de l'histogramme~:

            \begin{eqnarray}
            l \in \underset{i \in \ensemble{1}{N}} { \arg \min } \; h_i
            \end{eqnarray}

On d�finit ensuite l'intervalle $\cro{l_b,l_h}$ autour de $l$ v�rifiant~:

            \begin{eqnarray}
            \forall i \in \cro{l_b,l_h}, \; h_i \infegal \alpha \, h_l
            \end{eqnarray}

Le r�sultat de la figure~\ref{image_ligne_appui_fig} est obtenu pour $\alpha = 3$ ainsi que ceux de la figure~\ref{image_ligne_appui_fig_bad}. Ces formules peuvent �tre ajust�es manuellement sur quelques images. Puisqu'elles sont bas�es sur des histogrammes, elles sont en g�n�ral robustes. De plus, un �cart de quelques pixels n'alt�re pas les r�sultats de la reconnaissance, l'essentiel est de d�finir un rep�re qui permette de positionner les lettres les unes par rapport aux autres � partir d'une origine d�finie par les lettres. La seconde ligne d'appui repr�sente en quelque sorte un facteur d'�chelle.

            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=1cm, width=4cm]
        {\filext{../image/image/segline_appui}}\end{array}$}$$
        \caption{    Lignes d'appui encadrant la bande des minuscules}
            \indexfrr{ligne}{appui}
        \label{image_ligne_appui_fig}
            \end{figure}

            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=3cm, width=8cm]
        {\filext{../image/image/seg_appui_bad}}\end{array}$}$$
        \caption{    Mauvais positionnement des lignes d'appui~: les mots sont trop courts ou incluent 
                            des minuscules d�cor�es comme la lettre "i". Ces cas sont minoritaires.}
            \indexfrr{ligne}{appui}
        \label{image_ligne_appui_fig_bad}
            \end{figure}

Afin de limiter les erreurs comme celles pr�sent�es figure~\ref{image_ligne_appui_fig_bad}, les algorithmes incluent parfois une pr�classification des histogrammes en quatre classes qui d�terminent s'il faut chercher les lignes d'appui, une seule ou aucune~: (voir~\citeindex{Hennig2002})

            \begin{enumerate}
            \item mot sans ascendant, sans descendant
            \item mot avec ascendant(s), sans descendant
            \item mot sans ascendant, avec descendant(s)
            \item mot avec ascendant(s), avec descendant(s)
            \end{enumerate}

Le principe expos� ci-dessus est valable essentiellement pour des images de mots. Pour une ligne enti�re compos�e de plusieurs mots, m�me si la m�thode ci-dessus peut servir de premi�re approximation, elle doit �tre affin�e pour chacun des mots en utilisant les bo�tes englobantes des graph�mes par exemple (paragraphe~\ref{image_segmentation_grapheme}). L'article~\citeindex{Hennig2002} pr�sente une autre m�thode bas�e sur des splines r�solvant ce probl�me.





















\subsection{Estimation de l'�paisseur du trac�}
\label{image_epaisseur_trace}
\indexfr{�paisseur du trac�}

Selon les scripteurs, l'�criture peut-�tre plus ou moins �paisse (voir figure~\ref{image_trace_epaisseur}). Cette diff�rence n'est pas toujours int�ressante � prendre en compte (redressement de l'image) comme elle peut parfois �tre une donn�e non n�gligeable. Par exemple, on consid�re un histogramme de projection verticale utilis� pour la segmentation graph�me (paragraphe~\ref{image_segmentation_histogramme_direction}), ses minima locaux sont a priori sup�rieurs � l'�paisseur du trait qui peut servir de seuil de coupure.



            \begin{figure}[ht]
        $$\begin{array}{|c|c|}\hline 
        \includegraphics[height=1cm, width=3cm]{\filext{../image/image/attitude1}} &
        \includegraphics[height=1cm, width=3cm]{\filext{../image/image/attitude2}} \\ \hline
        \end{array}$$
        \caption{    Diff�rentes �paisseurs de trac� pour deux images dont les dimensions sont 206x69 pixels 
                            pour la premi�re et 211x97 pixels pour la seconde.}
        \label{image_trace_epaisseur}
            \end{figure}

L'article \citeindex{Abuhaiba1996} propose une estimation � partir d'une carte de distance\seeannex{ske_carte_distance_sec}{carte de distance} et d'un masque de distance d�fini comme suit~:

            $$
            \begin{array}{c|c|c}
            4 & 3 & 4 \\ \hline
            3 & 0 & 3 \\ \hline
            4 & 3 & 4 \\
            \end{array}
            $$

On note $d_*$ la valeur de la distance la plus fr�quente, l'�paisseur du trait $\widehat{e_0}$ est alors d�finie comme~:

            \begin{eqnarray}
            \widehat{e_0} &=& \frac{2}{3} \; d^* - 1
            \end{eqnarray}



\indexfrr{histogramme}{segment}
Cette estimation peut �tre aussi effectu�e au moyen d'histogrammes de projection. Une ligne ou une colonne de pixels extraite de l'image est constitu�e d'une suite de segments de la couleur de l'�criture. A priori, la longueur minimale de ces segments est �gale � l'�paisseur du trait. Par cons�quent, on construit l'histogramme $\pa{h_i}_{1 \infegal i }$ suivant~:

            \begin{eqnarray}
            \forall i \supegal 1, \; h_i &=& card  \acc{ \text{ segments de longueur $i$ } }
            \end{eqnarray}


La figure~\ref{image_trace_epaisseur_histo} illustre les histogrammes obtenus pour les deux images de la figure~\ref{image_trace_epaisseur}. La longueur (\ref{image_epaisseur_estimateur_1}) correspondant au maximum est une premi�re estimation de l'�paisseur du trait. Un second estimateur (\ref{image_epaisseur_estimateur_2}) est construit � partir de celui-ci dans le cas o� on consid�re que la distribution de la longueur des segments suit grossi�rement une loi normale autour de cet extremum~: 

        \begin{eqnarray}
        \widehat{e_1} &=&    \underset{i \supegal 1}{\arg \max} \; h_i \label{image_epaisseur_estimateur_1} \\
        \widehat{e_2}    &=&    \frac{1}{h} \; \summy{i = 1}{2\widehat{e_1}} \; i \; h_i  
                                                                                            \label{image_epaisseur_estimateur_2} 
        \end{eqnarray}



            \begin{figure}[ht]
        $$\begin{array}{|c|}\hline 
        \includegraphics[height=3cm, width=6cm]{\filext{../image/image/epais}} \\ \hline
        \end{array}$$
        \caption{    Histogramme de r�partition des longueurs des traits pour les deux images
                            de la figure~\ref{image_trace_epaisseur}.}
        \label{image_trace_epaisseur_histo}
            \end{figure}




        \begin{table}[ht]
    $$\begin{array}{|c|c|c|}\hline 
                                                & \text{premi�re image} & \text{seconde image} \\ \hline
      \widehat{e_1}                  &    4                                            & 10         \\ \hline
      \widehat{\sigma\pa{\widehat{e_2}}}         
                                                  &    0,15                      & 0,20 \\ \hline
    \end{array}$$
    \caption{    Valeurs obtenues par les deux estimateurs d�finis en (\ref{image_epaisseur_estimateur_1}) 
                        et (\ref{image_epaisseur_estimateur_2}) 
                        pour les deux images de la figure~\ref{image_trace_epaisseur}.}
    \label{image_trace_epaisseur_estimateur_valeur}
        \end{table}

\indexfr{largeur moyenne d'une lettre}

Cette �paisseur est calcul�e pour les deux images de la figure~\ref{image_trace_epaisseur} dans la table~\ref{image_trace_epaisseur_estimateur_valeur}. N�cessairement, la largeur d'une lettre d�passe l'�paisseur du trait et on peut vraisemblablement penser que la largeur des lettres est au moins sup�rieure � deux fois cette �paisseur (voir~\citeindex{Yanikoglu1998}).











\subsection{Estimation de la largeur moyenne d'une lettre}
\label{image_largeur_lettre}
\indexfr{largeur moyenne d'une lettre}

La largeur d'une lettre peut �tre une information int�ressante � prendre en compte lors de la segmentation en graph�mes. Cette grandeur est d'abord estim�e par la longueur moyenne entre deux transitions pixel noir - pixel blanc dans la bande des minuscules d�limit�es par les deux lignes d'appui estim�es au paragraphe~\ref{image_ligne_appui}. Cette estimation est not�e $e_l$ par la suite.







\subsection{Nettoyage de l'image}
\indexfr{nettoyage}


Les illustrations repr�sentent souvent des images binaires o� seul le mot � reconna�tre appara�t. Toutefois, ces images "propres" sont rarement celles imm�diatement obtenues apr�s scannerisation du document. Il n'existe pas de m�thodes g�n�rales associ�es � ces nettoyages car ils d�pendent fortement du type de documents � traiter et des informations qui doivent y �tre reconnues. Les algorithmes d�velopp�s sont donc sp�cifiques � un type pr�cis de document (ch�que, ordonnance, feuille de maladie, ...). N�anmoins, il se d�gage trois cat�gories de pr�traitements~: la binarisation (voir \citeindex{Kwon2004}) ou tout traitement d'image global, la localisation ou la recherche de l'information � reconna�tre et � extraire, le nettoyage proprement dit qui consiste � enlever tout ce qui peut g�ner la reconnaissance de la partie extraite, c'est un traitement local.

\indexfr{soulignement}
\indexfr{binarisation}

La figure~\ref{image_nettoyage_texte} est un exemple emprunt� � une image en niveaux de gris dont le fond est fonc�. La premi�re �tape consiste g�n�ralement � binariser l'image. Ce premier traitement n'est pas incontournable mais il permet de r�duire fortement la taille des images lors de la constitution de grandes bases de donn�es et d'utiliser des algorithmes fond�s sur la connexit�. L'image de la figure~\ref{image_nettoyage_texte} est d�j� le r�sultat d'une extraction dont il faut ensuite enlever le trait de soulignement et les formes situ�es au-dessous du mot. Le r�sultat de ces pr�traitements correspond � la seconde image de la figure~\ref{image_nettoyage_texte}.



            \begin{figure}[ht]
        $$\begin{array}{|c|c|}\hline 
        \includegraphics[height=1.5cm, width=4cm]{\filext{../image/image/nettoy}} &
        \includegraphics[height=1.5cm, width=4cm]{\filext{../image/image/nettoy2}} \\ \hline
        \end{array}$$
        \caption{    Un mot extrait d'une page en niveaux de gris, avant de pouvoir reconna�tre le mot, 
                            il faut binariser l'image et extraire le mot � reconna�tre ce qui revient 
                            � enlever le soulignement et les divers lettres ou trait situ�s en-dessous. 
                            La seconde image est issue de la premi�re apr�s avoir �t� nettoy�e.}
        \label{image_nettoyage_texte}
            \end{figure}

Les proc�dures de nettoyage du trait de soulignement consiste d'abord � estimer son �paisseur puis � enlever les pixels qui le composent en prenant soin de laisser les pixels communs aux lettres et au trait de soulignement. Ces derniers sont fr�quemment rep�r�s par une zone de sur-�paisseur due au chevauchement des traits.

\indexfr{histogramme}
\label{image_nettoyage_desolneux}

La d�tection des traits n'est pas non plus un probl�me simple m�me si, pour certains documents, le trait de soulignement est toujours pr�sent (�criture d'un nombre de famille sur une ligne horizontale par exemple). Il est possible d'utiliser des m�thodes � base d'histogrammes comme ceux pr�sent�s au paragraphe~\ref{image_seg_line}. Une autre m�thode int�ressante est pr�sent�e dans les articles \citeindex{Desolneux2000}, \citeindex{Desolneux2002}, \citeindex{Desolneux2003} qui propose un formalisme adapt� � la d�tection de toute figure g�om�trique simple comme un segment, un carr�, un cercle. Par exemple, un alignement de segments comme celui de la figure~\ref{image_nettoyage_texte_morel} n'est d�tect� que s'il est suffisamment isol� pour que sa pr�sence ne puisse pas �tre consid�r�e comme une co�ncidence. En r�sum�, � partir des segments pr�sents dans l'image, on quantifie d'abord la probabilit� d'obtenir un alignement quelconque de petits segments n'importe o� dans l'image ou plut�t le nombre moyen de segments faisant partie d'un alignement. S'il existe un ensemble de segments align�s sup�rieur au seuil d�termin� juste avant, alors, on consid�re que cet alignement est plus que probable. 


            \begin{figure}[ht]
        $$\begin{array}{|c|}\hline 
        \includegraphics[height=3cm, width=6cm]{\filext{../image/image/desol}}  \\ \hline
        \end{array}$$
        \caption{    Figure extraite de \citeindexfig{Desolneux2002}, les traits isol�s pr�sents
                            au bas de la figure paraissent align�s mais noy�s dans le nuage au-dessus, ils 
                            deviennent "invisibles".}
        \label{image_nettoyage_texte_morel}
            \end{figure}

\indexfr{squelettisation}
Une m�thode plus �labor�e d�crite dans \citeindex{Cheng2004} permet de d�barrasser l'image de mots manuscrits d'une ligne ou d'une courbe sur laquelle les lettres s'appuient, ou une courbe qui traverse l'image comme celle de l'exemple de la figure~\ref{image_nettoyage_ligne_courbe}. Cette m�thode s'appuie sur la construction d'un graphe qui r�sulte d'une squelettisation. La courbe principale d�coule d'une ou plusieurs recherche d'un plus court chemin.


            \begin{figure}[ht]
        $$\begin{array}{|c|}\hline 
        \includegraphics[height=5cm, width=8cm]{\filext{../image/image/cheng}}  \\ \hline
        \end{array}$$
        \caption{    Figure extraite de \citeindexfig{Cheng2004}, la premi�re image $(a)$ est l'image originale,
                            les deux images suivantes r�sultent du nettoyage de cette premi�re image, la courbe principale
                            et les mots ont �t� s�par�es.}
        \label{image_nettoyage_ligne_courbe}
            \end{figure}



%-------------------------------------------------------------------------------------------------------------
\section{Diverses segmentations en graph�mes}
%-------------------------------------------------------------------------------------------------------------
\indexfrr{segmentation}{graph�me}
\indexfr{graph�me}
\label{image_segmentation_grapheme}


La segmentation en graph�mes permet de d�localiser le probl�me de reconnaissance du niveau des mots au niveau des lettres. Reconna�tre l'image d'un mot sans la d�couper au pr�alable est une m�thode limit�e � des probl�mes restreints o� le nombre de mots est faible comme l'�criture d'un nombre en lettres. Comme la reconnaissance se r�sume � un probl�me de classification. Plus la liste des mots possibles est longue, plus le classifieur � construire est complexe. C'est pourquoi il est pr�f�rable de scinder ce probl�me de reconnaissance d'un mot en une somme de probl�mes plus simples qui sont la reconaissance des lettres pr�sentes dans l'image. 

\indexfr{MMC}\indexfrr{s�quence}{observation}
D�couper l'image soul�ve plusieurs questions dont la premi�re concerne le r�sultat � obtenir~: est-il d�pendant des mod�les de reconnaissance utilis�s par la suite~? Dans le cas de mod�les de Markov cach�s, le r�sultat souhait� est une s�quence d'observations, ce qui signifie que la seule dimension variable du d�coupage est le nombre d'objets ainsi form�s. Une extension de ces mod�les statistiques permet d'�tendre le concept de s�quence � un graphe d'observations incluant plusieurs options de segmentations. Toutefois, quelle que soit l'option choisie, elle r�sulte des compromis suivants~: 

            \begin{enumerate}
            \item Plus la segmentation poss�de de degr�s de libert� (plus elle propose d'alternatives), 
                        plus les mod�les de reconnaissance seront complexes, plus les mod�les de reconnaissance 
                        sont complexes, plus ils sont difficiles � apprendre.
            \item Moins la segmentation poss�de de degr�s de libert�, plus elle est susceptible de faire des erreurs.
            \end{enumerate}


Nous allons aborder une segmentation sous forme de s�quences de graph�mes. Cette �tape de segmentation est indispensable pour la construction d'un syst�me de reconnaissance de l'�criture, diverses m�thodes sont pass�es en revue dans les articles \citeindex{Lecolinet1991} ou plus r�cemment \citeindex{Lu1996}. Les paragraphes qui suivent reprennent quelques-unes des m�thodes pr�sent�es dans ces articles puis concluent sur la conception de la segmentation qui a �t� �labor�e dans le cadre de ces travaux de recherche. \indexfrr{accent}{graph�me}\indexfrr{graph�me}{accent} Cette segmentation propose �galement une solution au probl�me des accents dont la lettre d'attache est parfois situ�e assez loin, ce qui n'a pas �t� pris en compte jusqu'� pr�sent.
















\subsection{Segmentation � partir du squelette}
\indexfrr{segmentation}{graph�me}
\label{image_sequence_graphem}


\indexfr{ordonnancement}
\indexfrr{graph�me}{taille}
\indexfrr{graph�me}{ordonnancement}

Les graph�mes sont des images extraites de l'image � segmenter. Passer d'une seule image � une s�quence de graph�mes soul�ve deux probl�mes (voir~\citeindex{Baret1991}) qui sont la taille que doivent avoir les graph�mes et l'ordonnancement des morceaux segment�s. Ils ne doivent pas �tre trop petits afin d'�tre diff�rents les uns des autres, diff�rents d'un simple trait. Ils ne doivent pas �tre trop gros pour ne pas d�passer la taille d'une lettre. Chaque lettre repr�sentera entre un et trois graph�mes. Ce choix facilite l'ordonnancement des graph�mes qui doivent respecter le sens gauche-droite de la lecture. 


\indexfr{squelette}\indexfr{motifs}
L'image peut �tre rendue � l'�tat de squelette\seeannex{annexe_squelettisation}{squelettisation}. Ce dernier est ensuite parcouru de mani�re � rep�rer certains motifs synonymes de c�sure entre lettres (figure~\ref{image_graphe_cut}). La d�tection de ces motifs introduit des calculs de courbure, d'angle qui sont compar�s � des seuils ajust�s de mani�re � obtenir le r�sultat d�sir�. Ces algorithmes sont mieux d�taill�s dans~\citeindex{Lecolinet1991}.

            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=3cm, width=10cm]
        {\filext{../image/image/grm_cut}}\end{array}$}$$
        \caption{Segmentation � partir du squelette~: segmentation bas�e sur des motifs.}
        \label{image_graphe_cut}
            \end{figure}

La figure~\ref{image_graphe_noel} est un exemple de ce qui est obtenu et des probl�mes qui accompagnent l'utilisation de seuils. Les lettres en fin de mots, plus petites, sont parfois agr�g�es. La figure~\ref{image_grapheme_erreur} recense la liste de ces probl�mes.

            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=1.5cm, width=5cm]
        {\filext{../image/image/grm_noel}}\end{array}$}$$
        \caption{    Segmentation � partir du squelette~: 
                            chaque graph�me est entour� de sa bo�te englobante, les deux lignes horizontales
                            mod�lisent les lignes d'appui (ou lignes de bases) qui encadrent la bande o� 
                            sont �crites les lettres
                            minuscules (paragraphe~\ref{image_ligne_appui}).}
        \label{image_graphe_noel}
            \end{figure}







\subsection{Segmentation � partir du contour}
\indexfrr{segmentation}{graph�me}
\label{image_sequence_graphem_contour}
\indexfr{contour}


Cette m�thode esquiss�e dans~\citeindex{Madhvanath2001} ne s'int�resse pas au squelette mais uniquement au contour dont elle d�termine les meilleurs points candidats � une coupure entre graph�mes (voir figure~\ref{image_segmentation_contour}). Lors du parcours du contour, les extrema locaux sont marqu�s (point culminant et selle) puis les paires les plus proches sont regroup�es de part et d'autre du trait.


            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=2cm, width=4cm]
        {\filext{../image/image/grm_seg_bound}}\end{array}$}$$
        \caption{    Segmentation � partir du contour~: les points repr�sentent les minima et les maxima
                            locaux (ordonn�e des points) le long du contour. Les paires des points des plus
                            proches dispos�s de part et d'autre du trait
                            forment les candidats les plus probables pour une c�sure.
                            }
            \indexfrr{ligne}{appui}
        \label{image_segmentation_contour}
            \end{figure}


\indexfr{t�tonnement}
La direction de coupure n'est pas toujours horizontale comme le montre la figure~\ref{image_segmentation_contour2}. A l'instar de la m�thode pr�c�dente, la segmentation en graph�mes � partir du contour n�cessite de nombreux ajustements avant de trouver les crit�res de d�cision. Cette mise au point par t�tonnements est le point commun de nombreux traitements d'images li�es � l'�criture manuscrite. Faciles � ajuster lorsque la qualit� de l'�criture est bonne (figure~\ref{image_segmentation_contour}), ces pr�traitements peuvent avoir des comportements tout-�-fait erratiques lorsque l'�criture est de mauvaise qualit� (voir figure~\ref{image_graphe_grapheme}).


            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=2cm, width=4cm]
        {\filext{../image/image/grm_seg_bound2}}\end{array}$}$$
        \caption{    Segmentation � partir du contour~: si la c�sure du couple "Je" s'appuie sur les extrema 
                            environnants, sa direction est plus horizontale que verticale.}
        \label{image_segmentation_contour2}
            \end{figure}







            
            
\subsection{Ordonnancement}
\indexfrr{graph�me}{ordonnancement}
\indexfr{ordonnancement}
\indexfrr{graph�me}{s�quence}
\indexfrr{s�quence}{graph�me}
\label{image_ordonnancement}
\indexfr{voyageur de commerce}

Une fois la segmentation effectu�e, il ne reste plus qu'� ordonner les morceaux afin de former une s�quence d'observations. Ce probl�me n'est pas simple et doit inclure des �tapes de regroupement afin de traiter des probl�mes tels que des accents qui doivent �tre associ�s � une lettre. Dans un premier temps, les accents, les points, c'est-�-dire tout morceau isol� au-dessus de la ligne d'appui haute, ne sont pas int�gr�s par l'algorithme d'ordonnancement, ils sont affect�s aux graph�mes une fois ce dernier termin�. Ce probl�me d'ordonnancement est similaire au probl�me du voyageur de commerce. Une fois que les graph�mes de d�but et de fin sont d�termin�s, le plus court chemin reliant les graph�mes de d�but et de fin et incluant tous les autres graph�mes peut �tre assimil� � la s�quence la plus probable.








\subsection{Fen�tres glissantes}
\indexfrr{fen�tre}{glissante}
\label{image_fenetre_glissante}

D�couper l'image en bandelettes verticales est la segmentation la plus simple comme le montre la figure~\ref{image_window_slide}. Ce d�coupage peut �tre r�gulier ou d�pendre des minima d'un histogramme de projection par exemple, il peut �galement se recouvrir. L'inconv�nient de cette m�thode est qu'elle g�n�re trop de graph�mes regroupant les morceaux de plusieurs lettres, c'est d'ailleurs pourquoi les petites images obtenues se recouvrent en partie. Le paragraphe suivant~\ref{image_segmentation_histogramme_direction} �tend cette m�thode � plusieurs directions de projection pour les histogrammes. Cette repr�sentation est utilis�e par le syst�me de reconnaissance d�crit dans \citeindex{Knerr2001}.


    \begin{figure}[t]
    $$\frame{$\begin{array}[c]{c}\includegraphics[height=2cm, width=16cm]
     {\filext{../bibliographie/image/biblio_window_slide}}\end{array}$}$$
    \caption{    Image extraite de~\citeindexfig{Knerr2001} illustrant le d�coupage de l'image d'un mot 
                        par des fen�tres glissantes.}
    \label{image_window_slide}
    \end{figure}

\indexfr{connexit�}\indexfr{ordonnancement}
Cette m�thode comme la suivante d'ailleurs poss�de n�anmoins l'avantage par rapport � celle pr�sent�e dans les paragraphes~\ref{image_sequence_graphem} et~\ref{image_sequence_graphem_contour} de n'�tre pas d�pendante de la connexit� et d'�tre moins sensible au bruit. L'ordonnancement (voir paragraphe~\ref{image_ordonnancement}) est lui aussi �vident puisque la segmentation bas�e sur le squelette ou le contour produit des morceaux r�partis dans un espace en deux dimensions alors que cette m�thode segmente l'image selon l'axe des abscisses qui est aussi l'axe de lecture.







\subsection{Segmentation bas�e sur des histogrammes}
\indexfrr{segmentation}{histogramme}
\label{image_segmentation_histogramme_direction}
\indexfr{connexit�}
\indexfr{ordonnancement}


Cette m�thode est d�crite dans l'article~\citeindex{Yanikoglu1998} et produit une segmentation semblable � celle illustr�e figure~\ref{image_grapheme_segmentation_histogramme}. Elle consiste � d�terminer des droites de segmentation de l'image � partir d'histogrammes de projection effectu�s selon diff�rentes directions proches de la verticale. Ces droites sont choisies de telle sorte qu'elles interceptent le moins de pixels noirs et sont r�guli�rement espac�es dans l'image. Cette m�thode simple et peu d�pendante de la connexit� ne peut malgr� tout pas tout r�soudre comme en t�moignent les exemples de la figure~\ref{image_grapheme_segmentation_histogramme_bad}. La m�thode poss�de �galement l'avantage de ne pas �tre assujettie au probl�me d'ordonnancement (voir paragraphe~\ref{image_ordonnancement}).




            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=1cm, width=4cm]
        {\filext{../image/image/seg_dir_gra}}\end{array}$}$$
        \caption{    Segmentation en graph�mes � partir d'histogrammes de projection selon
                            plusieurs directions.}
        \label{image_grapheme_segmentation_histogramme}
            \end{figure}



            \begin{figure}[ht]
        $$\begin{array}{|c|c|c|} \hline
        \includegraphics[height=1cm, width=4cm]        {\filext{../image/image/histo_seg1}} &
        \includegraphics[height=1cm, width=2.5cm]    {\filext{../image/image/histo_seg2}} &
        \includegraphics[height=1cm, width=2.5cm]    {\filext{../image/image/lahs_black}} \\ \hline
        \end{array}$$
        \caption{    Deux exemples o� la segmentation par histogramme est difficilement applicable~:
                            le premier cas contient une barre de "t" qui sera n�cessairement coup�e puisqu'elle 
                            touche la lettre "a". Le second exemple contient le couple "op" fortement
                            li� du fait de l'�paisseur du trait, la liaison entre les 
                            deux lettres est plus �paisse qu'ailleurs. Le dernier mot pr�sente un couple
                            "La" qu'aucune droite ne saurait s�parer.}
        \label{image_grapheme_segmentation_histogramme_bad}
            \end{figure}








\subsection{Segmentation bas�e sur des r�servoirs}
\indexfrr{segmentation}{r�servoir}
\label{image_segmentation_reservoir}
\indexfr{r�servoir}


Cette id�e est d�velop�e dans l'article~\citeindex{Pal2003} et est appliqu�e dans le cadre d'une segmentation de chiffres cursifs. Elle consiste � d�tecter tout d'abord les vall�es et les collines s�parant deux chiffres appartenant � la m�me composante connexe, ces formes sont illustr�es pour un mot dans la figure~\ref{image_grapheme_reservoir}. Deux chiffres li�s dans une m�me composante seront s�par�s si une vall�e ou une colline repr�sente un espace suffisamment grand par rapport � la taille des chiffres. En ce qui concerne les lettres, les r�gles de d�cision sont plus difficiles � mettre en place car les lettres ont des hauteurs variables.


            \begin{figure}[ht]
        $$\begin{tabular}{|c|}\hline
        \includegraphics[height=2cm, width=4cm]{\filext{../image/image/reser}}
        \\ \hline \end{tabular}$$
        \caption{    Segmentation � partir de r�servoirs d'eau (\citeindexfig{Pal2003})~: 
                            les vall�es et les collines sont en quelque sorte    remplies d'eau, si elles
                            sont suffisamment profondes ou hautes, elles marquent la s�paration entre deux
                            caract�res.}
        \label{image_grapheme_reservoir}
        \indexfrr{r�servoir}{eau}
            \end{figure}

Une fois que les zones de coupures sont d�tect�es, il reste � d�terminer � quelle cat�gorie elle appartient (voir figure~\ref{image_grapheme_reservoir_cut}) afin de placer la c�sure � l'endroit le plus appropri�. Cette id�e est reprise dans~\citeindex{Elnagar2003} � ceci pr�s que la m�thode s'applique au squelette des chiffres et pas � l'image initiale.




            \begin{figure}[ht]
        $$\begin{tabular}{|c|}\hline
        \includegraphics[height=2cm, width=4cm]{\filext{../image/image/grmcut1}}
        \\ \hline \end{tabular}$$
        \caption{    Segmentation � partir de r�servoirs d'eau (\citeindexfig{Pal2003})~: deux points de coupures
                            diff�rents, le premier est situ� au fond d'une vall�e � droite sur un embranchement,
                            le second est situ� dans un creux, au milieu d'une courbe en "u". La coupure ne doit donc pas
                            toujours intervenir � l'endroit du minimum local.}
        \label{image_grapheme_reservoir_cut}
            \end{figure}











\subsection{Graphes de graph�mes}
\indexfrr{graphe}{graph�me}
\indexfrr{graph�me}{graphe}


La segmentation en graph�mes donne parfois des r�sultats erron�s. La figure~\ref{image_graphe_grapheme} propose une mani�re d'�viter ces erreurs en r�sumant au travers d'un graphe plusieurs options de segmentation. La s�quence de graph�mes est un cas particulier de ce graphe, elle est la segmentation la plus probable pour la partie qui concerne le traitement d'image mais pas forc�ment la meilleure pour la partie reconnaissance qui suit. Il peut donc �tre int�ressant de proposer plusieurs segmentations afin d'augmenter la probabilit� que la bonne segmentation soit trouv�e. Ce proc�d� revient souvent comme un leitmotiv dans la reconnaissance de l'�criture, il s'agit de retarder la prise de d�cision afin de conserver � chaque �tape le plus de solutions possibles.




            \begin{figure}[t]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=7.5cm, width=12cm]
        {\filext{../hmm_seq/image/graphe_obs}}\end{array}$}$$
        \caption{    Segmentation en graph�mes~: graphes. Aucune d�cision n'est prise � ce niveau, 
                            le choix de la bonne segmentation sera effectu� par le module de reconnaissance.}
        \label{image_graphe_grapheme}
            \end{figure}






%-------------------------------------------------------------------------------------------------------------
\section{Choix d'une segmentation en graph�mes}
%-------------------------------------------------------------------------------------------------------------
\indexfrr{segmentation}{graph�me}
\label{image_choix_segmentation}


La segmentation d�crite dans les paragraphes qui suivent fonctionne bien lorsque l'�criture est de bonne qualit�. Comme tous les algorithmes de segmentation fond�s sur des heuristiques, celui-ci ne peut traiter correctement la totalit� des images. Cependant sa construction met en lumi�re les difficult�s rencontr�es lorsque la qualit� de l'�criture d�cro�t et les ajustements rendus n�cessaires par des probl�mes r�currents.



\subsection{Segmentation � partir d'histogrammes}


Le choix d'une segmentation d�pend des mod�les de reconnaissance qui devront l'utiliser. Segmenter en lettres ou morceaux de lettres les mots illustr�s par la figure~\ref{image_grapheme_segmentation_histogramme_bad} ou~\ref{image_graphe_grapheme_ing} peut para�tre une gageure. Toutefois le paragraphe~\ref{hmm_bi_lettre} permet d'assouplir cette contrainte. La segmentation propos�e ici vise seulement le d�coupage d'un mot en morceaux pouvant aller d'une simple partie de lettre � des groupes de deux ou trois lettres, pourvu que ceux-ci soient ais�ment identifiables. L'objectif est aussi d'�viter le plus possible les traitements bas�s sur la connexit� car ils sont tr�s sensibles au bruit.


            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=1cm, width=2cm]
        {\filext{../image/image/being}}\end{array}$}$$
        \caption{    Segmentation en graph�me d'un mot couramment employ� en langue anglaise~: \textit{being}.
                            Les trois derni�res lettres "ing" sont simplement esquiss�es.}
        \label{image_graphe_grapheme_ing}
            \end{figure}


L'impossibilit� de qualifier la pertinence d'une segmentation demeure un inconv�nient majeur, il est en effet difficile d'appr�cier directement un pr�traitement de l'image dont on attend les b�n�fices seulement en fin de cha�ne, c'est-�-dire en terme de taux de reconnaissance. L'appr�ciation n'est donc que visuelle.

\indexfrr{segmentation}{contour}
\indexfrr{segmentation}{squelette}
\indexfrr{segmentation}{histogramme}

L'approche propos�e ici est un compromis. La premi�re �tape consiste � segmenter gr�ce � la m�thode des histogrammes (paragraphe~\ref{image_segmentation_histogramme_direction}) en ne conservant que des coupures �videntes. Un premier ensemble de points de coupures est ainsi obtenu parmi lesquels seront s�lectionn�s ceux d�finissant la segmentation en graph�mes finale. Ce dernier r�sultat n'est pourtant pas encore parfait, ce que tenteront de corriger les m�thodes bas�es sur les contours ou les r�servoirs, celles-ci permettront ensuite de couper les morceaux litigieux.

Tout d'abord, les pixels sont projet�s selon sept directions entourant la direction verticale $-30^o$, $-20^o$, $-10^o$, $0^o$, $10^o$, $20^o$, $30^o$.  On note $\pa{h_{ij}} _ { \begin{subarray}{c} -3 \infegal i \infegal 3 \\ 1 \infegal j \infegal X \end{subarray} }$ les sept histogrammes obtenus o� $X$ est la longueur de l'image. $h_{ij}$ est donc le nombre de pixels noirs (�crits) selon une droite formant un angle $i \times 10^o$ avec la verticale et interceptant la ligne d'appui basse au point d'abscisse $j$. Ces histogrammes sont ensuite liss�s par une moyenne mobile analogue aux formules~(\ref{image_lissage_equation}). On d�finit $e_t$ comme �tant l'�paisseur du trac� (paragraphe~\ref{image_epaisseur_trace}), $e_l$ correspond � la largeur moyenne d'une lettre estim�e au paragraphe~\ref{image_largeur_lettre}. Enfin $C$ est l'ensemble de coupures et d�fini par~:


            \begin{eqnarray}
            C &=&  \acc{ h_{ij} \sac h_{ij} \infegal \beta \, e_t } \text{ o� } \beta \supegal 1
            \label{image_graphem_seg_eq_1}
            \end{eqnarray}


Le param�tre $\beta$ est g�n�ralement compris entre $1$ et $2$ de mani�re � ne pas couper un mot selon une droite interceptant deux fois le trac�. Il est possible d'�crire l'ensemble $C$ comme une r�union d'intervalles.


            \begin{eqnarray}
            C &=& \union{k=-3}{3} \union{i=1}{I} \; \cro{a_i^k, b_i^k} 
                                            \text{ avec } \left\{ \begin{array}{l}
                                                                a_i^k \infegal b_i^k < a^k_{i+1} \; \forall i,k \\
                                                                h_x^k \infegal \beta \, e_t \; \forall x \in \cro{a_i^k, b_i^k}
                                                                \end{array} \right.
            \label{image_graphem_seg_eq_2}
            \end{eqnarray}



Pour chaque intervalle de la forme $\cro{a_i^k, b_i^k}$, on v�rifie que $b_i^k - a_i^k \infegal e_l$. Dans le cas contraire, on scinde cet intervalle jusqu'� ce que chacun des morceaux soit inf�rieur � $e_l$. La figure~\ref{image_graphem_zone_coupure_soulignement} soul�ve le probl�me de soulignement. Etant donn� la condition exprim�e en~(\ref{image_graphem_seg_eq_2}), il est impossible de s�lectionner une seule zone de coupure probable entre graph�mes. Par cons�quent, la solution adopt�e est l'introduction de points de coupure entre les zones de non-coupure correspondant � des minima locaux. 

            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=1.6cm, width=3cm]
        {\filext{../image/image/souligne}}\end{array}$}$$
        \caption{    S�lection des zones de coupures entre graph�mes~: probl�me des mots soulign�s,
                            l'histogramme repr�sent� correspond � une projection verticale liss�e par une 
                            moyenne mobile uniforme d'ordre trois.}
        \label{image_graphem_zone_coupure_soulignement}
        \indexfr{soulignement}
            \end{figure}
            
Dans ce cas, pour une direction donn�e $k$, l'ensemble des points de coupures correspond aux minima locaux de l'histogramme $\pa{h_i^k}_i$. Un minimum $m^k$ local v�rifie la condition suivante~:

            \begin{eqnarray}
            h^k_{m^k} &=& \min \acc{ h_x^k \sac  m^k - e_t \infegal x \infegal m^k + e_t } 
            \label{image_graphem_seg_eq_2_prime}
            \end{eqnarray}


Ces minima locaux n'existent pas toujours, dans ces cas, on cherche � d�terminer le point $c_i^k \in \cro{a_i^k, b_i^k}$, l'unique point de coupure de la zone de coupure $\cro{a_i^k, b_i^k}$. La figure~\ref{image_grapheme_reservoir_cut} sugg�re que ce point se situe � droite du milieu de cet intervalle, par cons�quent, $\tau_2 > \tau_4 > \tau_3$ dans la d�finition suivante~:

            \begin{eqnarray}
            m_i^k    &=&                    \frac{a_i^k + b_i^k}{2} \nonumber \\
            c^k_i &=&               \underset{x \in \pa{a_i^k, b_i^k}}{\arg \min} \; \cro {
                                                \tau_1     \, \frac{h_x^k}{e_t}  + 
                                                \frac{4}{e_l^2}    \cro{ \indicatrice{x < m_i^k} 
                                                                                                \pa{\tau_2 - \tau_3} + \tau_3}  \;
                                                                                  \cro{x - m_i^k}^2  +
                                                \frac{2 \tau_4 \; e_t^2}{e_t^2 + \abs{s_{x^-}^k - s_{x^+}^k} }
                                                }
            \label{image_graphem_seg_eq_3}
            \end{eqnarray}
            

\indexfrr{droite}{coupure}
\indexfrr{ligne}{appui}


            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=2cm, width=2cm]
        {\filext{../image/image/cutcut}}\end{array}$}$$
        \caption{    D�finition des nombres $s_{x^-}^k$ et $s_{x^+}^k$ de la 
                            formule~(\ref{image_graphem_seg_eq_3}). $s_{x^-}^k$ correspond au nombre de pixels contenus
                            dans la premi�re colonne du rectangle quadrill� (couleur gris fonc�), $s_{x^+}^k$ correspond
                            � la colonne de droite (couleur noire). Le c�t� des petits carr�s est �gal � $e_t$ soit
                            l'�paisseur moyenne de l'�criture.
                            }
        \label{image_graphem_aire_cut}
            \end{figure}



Les nombres $s_{x^-}^k$ et $s_{x^+}^k$ sont d�finis par la figure~\ref{image_graphem_aire_cut}. L'ensemble $\acc{c^k_i}_{ik}$ est l'ensemble des droites de segmentation possibles s�lectionn�es par l'algorithme, cet ensemble est tri� par $i$ et $k$ croissant ($i$ d'abord, l'indice $k$ d�partageant les points de m�me indice $i$) et aboutit � la suite $\pa{d_n}_{ 1 \infegal n \infegal N }$. Il reste � d�terminer quelles sont parmi les points de cette suite les droites de segmentation les plus pertinentes.


A cette suite, sont ajout�s les �l�ments s�lectionn�s par l'�quation~(\ref{image_graphem_seg_eq_2_prime}) et deux �l�ments $d_0$ et $d_{N+1}$ qui correspondent aux deux s�parations verticales de d�but et de fin, c'est-�-dire les limites de l'image. On suppose qu'il existe une distance entre deux droites de coupures $i$ et $j$ not�e $\pa{D_{ij}}_{ 0 \infegal i,j \infegal N+1 }$, trouver la meilleure segmentation revient alors � trouver le plus court chemin entre les n\oe uds $d_0$ et $d_{N+1}$ en passant ou non par $n$ autres n\oe uds $\pa{d_n}_{ 1 \infegal n \infegal N }$. Ce probl�me est usuel et r�solu par un algorithme du plus court chemin de type Djikstra (voir \citeindex{Dijkstra1971}). Il reste � d�terminer la distance $D_{ij}$ entre deux droites de coupures qui doit prendre en compte trois �l�ments~:

        \indexfr{Djikstra}
        \indexfr{plus court chemin}
        \indexfr{droite de coupure!distance@distance}

        \begin{enumerate}
        \item Le nombre de pixels noirs intercept�s par les droites de coupures, not� $p_i$ et $p_j$.
        \item Le fait que les droites s'interceptent ou non, not� $t_{ij} \in \acc{0,1}$ 
                        (voir figure~\ref{image_droite_coupure_croisees}).
        \item La distance entre les deux points d'intersection des deux droites avec la ligne d'appui basse, 
                        not�e $d_j - d_i$ cette distance devrait �tre proche de 
                        $\lambda_4$ fois la largeur suppos�e d'une lettre, not�e $e_l$ et calcul�e au 
                        paragraphe~\ref{image_largeur_lettre}.
        \end{enumerate}
        


            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=1cm, width=2cm]
        {\filext{../image/image/droit_sec}}\end{array}$}$$
        \caption{    Droites de coupures s�cantes issues d'une segmentation non pertinente, 
                            deux droites de coupures peuvent se croiser, auquel cas, 
                            il n'est pas tr�s pertinent de les associer ensemble pour former la segmentation en graph�mes. }
        \label{image_droite_coupure_croisees}
            \end{figure}

A chaque abcisse $d_i$ est associ� un angle $u_i$ qui correspond � la direction de l'histogramme qui a permis d'obtenir $d_i$. A l'aide de ces notations, la distance $D_{ij}$ est d�finie par~:

            \begin{eqnarray}
            D_{ij} &=&             \lambda_1 \frac{p_i + p_j} {e_t} + 
                                            \lambda_2 \, t_{ij} + 
                                            \lambda_3 \frac{\pa{ d_j - d_i - \lambda_4 e_l}^2} {e_l^2} +
                                            \lambda_5 \pa{u_j - u_i}^2 
                                            \label{image_distance_droite_coupure}
            \label{image_graphem_seg_eq_4}
            \end{eqnarray}


            \begin{figure}[ht]
        $$\begin{tabular}{|c|c|c|c|c|} \hline
        \includegraphics[height=1cm, width=3cm]{\filext{../image/image/lahsene}} &
        \includegraphics[height=1cm, width=3cm]{\filext{../image/image/grtemp1}} &
        \includegraphics[height=1cm, width=3cm]{\filext{../image/image/grtemp2}} &
        \includegraphics[height=1cm, width=3cm]{\filext{../image/image/grtemp3}} & 
        \includegraphics[height=1cm, width=3cm]{\filext{../image/image/grtemp4}} \\ 
        \textit{(a)} & \textit{(b)} & \textit{(c)} & \textit{(d)} & \textit{(e)} \\ \hline
        \end{tabular}$$
        \caption{    R�sultat interm�diaire de la segmentation graph�me apr�s obtention du meilleur
                            chemin dans le graphe d�fini par la matrice d'adjacence 
                            (\ref{image_distance_droite_coupure}). Les valeurs des param�tres utilis�es
                            pour cet exemple sont donn�es par le tableau~\ref{image_graphem_segmentation_parametre}, 
                            page~\pageref{image_graphem_segmentation_parametre}.}
        \label{image_segmentation_grapheme_1}
            \end{figure}


En pratique, $\lambda_4$ est choisi proche de $1$, $\lambda_2$ est grand, $\lambda_3$ et $\lambda_1$ sont choisis proches de $1$. Divers probl�mes subsistent apr�s ce traitement illustr� par la figure~\ref{image_segmentation_grapheme_1}, il reste des bouts de lettres mal appari�s, des accents mal plac�s, des couples de lettres ins�parables par une droite et pourtant form�s de deux composantes connexes ou presque disjointes, des petits morceaux qu'on pourrait associer � un graph�me voisin plus gros. Ce d�coupage plus fin s'effectue en deux �tapes~:


        \begin{enumerate}
        \item D�coupage d'un graph�me contenant deux formes reli�es par un pont de pixels 
                    comme le couple "lf" de l'image~\textit{(c)} de la figure~\ref{image_segmentation_grapheme_1}.
        \item D�coupage d'un graph�me contenant plusieurs composantes connexes de tailles suffisantes pour �tre scind�es
                    en plusieurs graph�mes, image \textit{(e)} de la figure~\ref{image_segmentation_grapheme_1}.
        \end{enumerate}






\subsection{Segmentation � partir de "r�servoirs"}
\label{image_segmentation_reservoir_graphem}
\indexfr{r�servoir}
\indexfrr{graph�me}{r�servoir}

\indexfr{vall�e}\indexfr{colline}            

Comme le montre la figure~\ref{image_segmentation_grapheme_1}, le traitement pr�c�dent laisse quelques imperfections qu'il serait possible de r�sorber en utilisant la m�thode des r�servoirs illustr�e par la figure~\ref{image_grapheme_reservoir} et d�velopp�e dans~\citeindex{Pal2003}. On consid�re les vall�es et les collines dont la profondeur est sup�rieure � $\eta_1 e_t$ et la surface est sup�rieure � $\eta_2 \, e_t \pa{e_l-e_t}$. Il s'agit ensuite d'isoler les parties du trac� qui constituent le fond des vall�es et des collines et susceptibles d'�tre coup�es. Ce trac� correspond � la fronti�re d'une vall�e ou d'une colline dont la largeur d�cro�t, cette fronti�re inclut le fond de la vall�e ou le sommet d'une colline not� $\pa{x^v, y^v}$. Si $e_t\pa{x}$ est l'�paisseur du trac� � l'abscisse $x$, il est possible de choisir le point de coupure $c_v$ en s'inspirant de l'�quation~(\ref{image_graphem_seg_eq_3})~:


            \begin{eqnarray}
            c^v &=&                 \underset{\pa{x,y} \in \textit{vall�e}}{\arg \min} \; \cro {
                                                \tau_1     \, \frac{e_t\pa{x}}{e_t}  + 
                                                \frac{4}{e_l^2}    \cro{ \indicatrice{x < x^v} 
                                                                                                \pa{\tau_2 - \tau_3} + \tau_3}  \;
                                                                                  \cro{x - x_v}^2  +
                                                \frac{\tau_5}{e_t} \, \abs{y - y^v}
                                                }
            \label{image_graphem_reservoir_1}
            \end{eqnarray}

\indexfrr{vall�e}{sans fond}        
\label{image_valley_eta}    

L'algorithme d�crit dans~\citeindex{Pal2003} s'applique � l'ensemble du mot, il coupe en deux l'image du mot, puis r�it�re le proc�d� pour chaque morceau obtenu jusqu'� qu'il ne puisse plus couper. Ce processus sera �galement appliqu� � chaque graph�me. Il reste � traiter le cas des vall�es sans fond comme celle de la figure~\ref{image_graphem_reservoir_vallee_sans_fond}. Comme pr�c�demment, si la largeur de cette vall�e correspondant � la partie gris�e est sup�rieure � $\eta_2 e_t \, \pa{e_l - e_t}$, alors le graph�me sera scind�.



            \begin{figure}[ht]
        $$\frame{$\begin{array}[c]{c}\includegraphics[height=1.5cm, width=1cm]
        {\filext{../image/image/grmvalno}}\end{array}$}$$
        \caption{    Segmentation � partir de r�servoirs~: vall�e sans fond, la partie gris�e correspond � la 
                            largeur de la vall�e, si celle-ci est sup�rieure � $e_l e_t$, alors le graph�me sera
                            scind� en deux morceaux. }
        \label{image_graphem_reservoir_vallee_sans_fond}
            \indexfrr{vall�e}{sans fond}        
            \end{figure}
            
\indexfrr{graph�me}{accent}
\indexfrr{accent}{graph�me}


Vient ensuite le probl�me des accents qui se pr�sente sous deux formes~\textit{image~(a)} et~\textit{images~(c)-(d)} de la figure~\ref{image_graphem_reservoir_decouper_accent}. Dans le premier cas, il suffit de s�parer deux composantes connexes en utilisant une vall�e sans fond. Le second cas para�t impossible, le point de la lettre "i" vient toucher la lettre "d" (image~\textit{(c)}) ou la lettre "a" (image~\textit{(d)}). Le probl�me pos� par l'image~\textit{(e)} ou~\textit{(f)} appara�t fr�quemment, il s'agit de lettres dont les trac�s parall�les se chevauchent, comme les couples "oc" ou "cl" des images~\textit{(d)} et~\textit{(e)} de la figure~\ref{image_graphem_reservoir_decouper_accent}.

            \begin{figure}[ht]
        $$\begin{tabular}{|c|c|c|c|c|c|} \hline
        \includegraphics[height=1.5cm, width=1cm]{\filext{../image/image/valaccent}}     &
        \includegraphics[height=1.5cm, width=1cm]{\filext{../image/image/valaccent2}}     &
        \includegraphics[height=1cm, width=3cm]{\filext{../image/image/valaccent3}}         &
        \includegraphics[height=1cm, width=3cm]{\filext{../image/image/valaccent4}}         &
        \includegraphics[height=1cm, width=3cm]{\filext{../image/image/valaccent5}}         &
        \includegraphics[height=1cm, width=3cm]{\filext{../image/image/valaccent6}} 
        \\ \textit{(a)} & \textit{(b)} & \textit{(c)} & \textit{(d)} & \textit{(e)} & \textit{(f)} 
        \\ \hline
        \end{tabular}$$
        \caption{    Segmentation � partir de r�servoirs~: cas des accents, il serait pr�f�rable que 
                            ceux-ci soient dissoci�s de la s�quence de graph�mes car leur position est variable.
                            Toutefois, aucune vall�e ne permet de s�parer l'accent (image~\textit{(a)}) 
                            � moins de consid�rer la transpos�e de l'image, mais dans ce cas, certaines lettres comme celle 
                            de l'image~\textit{(b)} seraient coup�es par la m�thode des r�servoirs. 
                            De plus, comment d�tecter l'accent de l'image~\textit{(c)} 
                            ou celui de l'image~\textit{(d)}~? Comment traiter le probl�me des traits 
                            parall�les se chevauchant (images~\textit{(e)} ou~\textit{(f)} et des couples "oc" et "cl")~?
                            } 
           \indexfrr{graph�me}{accent}
        \label{image_graphem_reservoir_decouper_accent}
            \end{figure}

\indexfr{composante connexe}

Parmi ces diff�rents probl�mes, seul le cas des accents appartenant � des composantes connexes diff�rentes sera trait�. Les autres n'apparaissent que pour des couples ou des groupes de lettres pr�cis et seront mod�lis�s ult�rieurement notamment (voir paragraphe~\ref{hmm_bi_lettre}, page~\pageref{hmm_bi_lettre}). Il n'est pas non plus n�cessaire de traiter des probl�mes qui ne surviennent que peu fr�quemment, des d�veloppements sp�cifiques risquent d'introduire de mauvais cas parmi ceux d�j� bien trait�s. Un motif trop peu fr�quent ne peut �tre appris par des mod�les probabilistes tels que les cha�nes de Markov cach�es et les r�seaux de neurones, et ce, qu'il soit bien ou mal segment�.


L'algorithme qui suit permet de d�terminer la profondeur des vall�es, celle des collines s'en d�duit facilement. On cherche la vall�e la plus profonde et pour ce faire, on construit la matrice $v\pa{x,y}_{ \begin{subarray}{c} 1 \infegal x \infegal X \\ 1 \infegal y \infegal Y \end{subarray}}$ o� $\pa{x,y}$ est un pixel de l'image. Cette matrice est d�finie par l'algorithme suivant~\ref{image_algorithm_vpaxy_profondeur}.


        \begin{xalgorithm}{profondeur des vall�es, calcul de
                                                $v\pa{x,y}$
                                                %$v\pa{x,y}_{ \begin{subarray} 
                                                %    1 \infegal x \infegal X \\ 1 \infegal y \infegal Y     \end{subarray}}$
                                                    }
        \label{image_algorithm_vpaxy_profondeur}
        
        On consid�re une image $I\pa{x,y}$ de dimension $\pa{X,Y}$, on note la propri�t� qu'un pixel 
        soit noir par $N\pa{x,y}$. Le premier pixel est le coin sup�rieur gauche.
        $v\pa{x,y}$ d�signe la profondeur de la vall�e.
                
        \begin{xalgostep}{initialisation}
        \begin{xfor}{x}{1}{X}
            $v\pa{x,Y} \longleftarrow 0$ 
        \end{xfor}
        \end{xalgostep}
            
        \begin{xalgostep}{mise � jour}
        \begin{xfor}{y}{Y-1}{1}
            \begin{xfor}{x}{1}{X}
            $v\pa{x,y} \longleftarrow \left\{ \begin{array} {ll}
                                                0                         & \text{si } N\pa{x,y} \\
                                                v\pa{x,y+1}+1 & \text{sinon}
                                                \end{array} \right.$ 
            \end{xfor} \\
            \begin{xfor}{x}{2}{X}
            $v\pa{x,y} \longleftarrow \left\{ \begin{array} {ll}
                                                0                                                                                       & 
                                                                \text{si } \forall i \infegal x, \; N\pa{i,y} \text{ est faux}\\
                                                max \acc{\; v\pa{x,y}, \; v\pa{x,y+1}+1 \; }        & \text{sinon}
                                                \end{array} \right.$ 
            \end{xfor} \\
            \begin{xfor}{x}{X-1}{1}
            $v\pa{x,y} \longleftarrow \left\{ \begin{array} {ll}
                                                0                                                                                       & 
                                                                \text{si } \forall i \supegal x, \; N\pa{i,y} \text{ est faux}\\
                                                max \acc{\; v\pa{x,y}, \; v\pa{x,y+1}+1 \; }        & \text{sinon}
                                                \end{array} \right.$ 
            \end{xfor}
            \begin{xfor}{x}{2}{X}
            $v\pa{x,y} \longleftarrow \left\{ \begin{array} {ll}
                                                0                                                                                       & \text{si } N\pa{x,y} \\
                                                max \acc{ \; v\pa{x-1,y}, \; v\pa{x,y} \; }      & \text{sinon}
                                                \end{array} \right.$ 
            \end{xfor} \\
            \begin{xfor}{x}{X-1}{1}
            $v\pa{x,y} \longleftarrow \left\{ \begin{array} {ll}
                                                0                                                                                       & \text{si } N\pa{x,y} \\
                                                max \acc{ \; v\pa{x,y}, \; v\pa{x+1,y} \; }      & \text{sinon}
                                                \end{array} \right.$ 
            \end{xfor} \\
        \end{xfor}
        \end{xalgostep}
        
        Le maximum atteint sur la premi�re ligne de l'image correspond � la vall�e la plus profonde.
                                                    
        \end{xalgorithm}                                                    
         

En conservant en chaque point de l'image le pixel qui a permis d'atteindre le maximum, il est possible d'en d�duire la surface de la vall�e la plus profonde. L'algorithme peut �tre adapt� de mani�re � estimer la surface de la colline la plus profonde. Il reste � d�terminer l'�paisseur locale de l'�criture depuis une position particuli�re sur le contour, ce qui n'est pas toujours �vident comme le montre la figure~\ref{image_graphem_valley_where_to_cut}.



            \begin{figure}[ht]
        $$\begin{tabular}{|c|} \hline
        \includegraphics[height=3cm, width=2cm]{\filext{../image/image/valleyt}} \\ \hline
        \end{tabular}$$
        \caption{    Cette figure illustre une vall�e qui propose trois directions diff�rentes de coupure
                            afin de segmenter ce graph�me en deux composantes connexes. La premi�re direction 
                            (vers la gauche n'est pas adapt�e, la direction verticale est souvent la meilleure,
                            la derni�re (la plus � droite) m�ne vers une boucle. Ces trois directions correspondent
                            � trois mesures de l'�paisseur du trac�.
                        }
        \label{image_graphem_valley_where_to_cut}
            \end{figure}

            
Sur les trois directions propos�es par la figure~\ref{image_graphem_valley_where_to_cut}, seules deux seront conserv�es, celles qui permettent de relier un point de la vall�e � un point n'y appartenant pas mais pour lequel il existe un chemin le reliant � l'un des bords de l'image, autrement dit, � un point non inclus dans une boucle. Le segment de coupure doit �tre le plus vertical possible, la distance entre un point $\pa{x^v,y^v}$ de la vall�e et un point de l'ext�rieur $\pa{x^e,y^e}$ est donn�e par~:


            \begin{eqnarray}
            d\pa{ \pa{\begin{subarray}{c} x^y \\ y^v \end{subarray}}, 
                        \pa{\begin{subarray}{c} x^e \\ y^e \end{subarray}}} &=&
                        \abs{ x^v - x^e } + \mu \, \abs{ y^v - y^e }
                        \label{image_graphem_reservoir_2}
            \end{eqnarray}

Le nombre $e_t\pa{\begin{subarray}{c} x^y \\ y^v \end{subarray}}$ d�fini dans l'�quation~\ref{image_graphem_reservoir_1} est alors �gal �~:

            
            \begin{eqnarray}
            e_t\pa{\begin{subarray}{c} x^y \\ y^v \end{subarray}} &=&
                        \underset{\pa{x^e,y^e}}{\min} \; 
                        d\pa{ \pa{\begin{subarray}{c} x^y \\ y^v \end{subarray}}, 
                        \pa{\begin{subarray}{c} x^e \\ y^e \end{subarray}}}
                        \label{image_graphem_reservoir_3}
            \end{eqnarray}




\subsection{D�tection des accents}
\indexfr{composante connexe}
\label{image_segmentation_connexe_graphem}

L'�tape suivante consiste � extraire les accents et les points de la s�quence de graph�mes d�j� obtenue afin de les placer dans une autre s�quence. L'id�e la plus simple utilise une s�paration horizontale de l'image repr�sent�e par la figure~\ref{image_graphem_valley_accent_d}. Si cette division est possible, la distance entre les deux objets est alors sup�rieure � $\pa{\zeta_1 e_t}$ et la surface de l'accent est sup�rieure � $\pa{\zeta_2 \,\frac{\pi}{4} \, e_t^2}$. Dans ce cas, l'objet sup�rieur sera nettoy� de la s�quence de graph�mes et ins�r� dans la s�quence des accents.


            \begin{figure}[ht]
        $$\begin{tabular}{|c|} \hline
        \includegraphics[height=2cm, width=2cm]{\filext{../image/image/accentd}} \\ \hline
        \end{tabular}$$
        \caption{    Deux objets s�par�s par une ligne horizontale. 
                            La double fl�che repr�sente la distance qui les s�pare. }
        \label{image_graphem_valley_accent_d}
            \end{figure}
            




\subsection{Recollement de petits segments}
\indexfrr{graph�me}{recollement}

Il arrive parfois que les m�thodes d�crites dans les paragraphes~\ref{image_segmentation_reservoir_graphem} et~\ref{image_segmentation_connexe_graphem} divisent les graph�mes de mani�re trop fine, en particulier en ce qui concerne les traits quasiment horizontaux. Il est parfois utile de recoller de trop petits segments aux lettres voisines afin d'�viter qu'ils ne soient consid�r�s comme des points.








\subsection{Illustration et r�sultats}
\label{image_illustration_resultat}


            \begin{table}[t]
            $$
            \begin{array}{|c|c|c|c|} \hline
            \text{param�tre}     &     \text{valeur} & \text{�quation} & \text{page} \\ \hline
            \beta                         &     1,5                     &    (\ref{image_graphem_seg_eq_2})     
                                                                                    & \pageref{image_graphem_seg_eq_2} \\ \hline
            \tau_1                         &     1                       &    (\ref{image_graphem_seg_eq_3})     
                                                                                    & \pageref{image_graphem_seg_eq_3}    \\ \hline
            \tau_2                        &     1                       &    (\ref{image_graphem_seg_eq_3})     
                                                                                    & \pageref{image_graphem_seg_eq_3}    \\ \hline
            \tau_3                        &     0,2                      &    (\ref{image_graphem_seg_eq_3})     
                                                                                    & \pageref{image_graphem_seg_eq_3}    \\ \hline
            \tau_4                        &     0,3                     &    (\ref{image_graphem_seg_eq_3})     
                                                                                    & \pageref{image_graphem_seg_eq_3}    \\ \hline
            \tau_5                        &     1                       &    (\ref{image_graphem_reservoir_1}) 
                                                                                    & \pageref{image_graphem_reservoir_1}    \\ \hline
            \lambda_1                 &     1                       &    (\ref{image_graphem_seg_eq_4})     
                                                                                    & \pageref{image_graphem_seg_eq_4}    \\ \hline
            \lambda_2                    &     1000                     &    (\ref{image_graphem_seg_eq_4})     
                                                                                    & \pageref{image_graphem_seg_eq_4}    \\ \hline
            \lambda_3                    &     1                       &    (\ref{image_graphem_seg_eq_4})     
                                                                                    & \pageref{image_graphem_seg_eq_4}    \\ \hline
            \lambda_4                    &     1                       &    (\ref{image_graphem_seg_eq_4})     
                                                                                    & \pageref{image_graphem_seg_eq_4}    \\ \hline
            \lambda_5                  &     0,1                      &    (\ref{image_graphem_seg_eq_4})     
                                                                                    & \pageref{image_graphem_seg_eq_4}    \\ \hline
            \eta_1                      &     1                        &    (\ref{image_valley_eta})                 
                                                                                    & \pageref{image_valley_eta}    \\ \hline
            \eta_2                      &     0,5                      &    (\ref{image_valley_eta})                 
                                                                                    & \pageref{image_valley_eta}    \\ \hline
            \mu                          &     5                        &    (\ref{image_graphem_reservoir_2}) 
                                                                                    & \pageref{image_graphem_reservoir_2}    \\ \hline
            \zeta_1                   &     1                        &    (\ref{image_segmentation_connexe_graphem}) 
                                                                                    & \pageref{image_segmentation_connexe_graphem}    \\ \hline
            \zeta_2                    &     1                        &    (\ref{image_segmentation_connexe_graphem}) 
                                                                                    & \pageref{image_segmentation_connexe_graphem}    \\ \hline
            \end{array}
            $$
            \caption{    Liste des param�tres et valeurs utilis�s pour la segmentation
                                d'un mot en graph�mes, ces param�tres sont ajust�s manuellement � la vue des r�sultats
                                obtenus sur quelques images prises 
                                au hasard dans une large base de donn�es ou s�lectionn�es de mani�re automatique
                                en assimilant les graph�mes mal segment�s � des graph�mes peu probables 
                                (voir paragraphe~\ref{reco_densite_valeur_aberrante}, page~\pageref{reco_densite_valeur_aberrante}).}
            \label{image_graphem_segmentation_parametre}
            \indexfrr{graph�me}{param�tre}
            \end{table}
            
                                            
            \begin{figure}[t]
        $$\begin{tabular}{|c|c|c|} \hline
        \includegraphics[height=2cm, width=6cm]{\filext{../image/image/finalgrm1}} &
        \includegraphics[height=2cm, width=4cm]{\filext{../image/image/finalgrm2}} &
        \includegraphics[height=2cm, width=6cm]{\filext{../image/image/finalgrm3}} \\
        \textit{(a)} & \textit{(b)} & \textit{(c)} \\ \hline
        \includegraphics[height=2cm, width=5cm]{\filext{../image/image/finalgrm4}} & &
        \includegraphics[height=2cm, width=5cm]{\filext{../image/image/finalgrm5}}  \\ 
        \textit{(d)} & & \textit{(e)}  \\ \hline
        \end{tabular}$$
        \caption{    R�sultat final de la segmentation graph�me. Les valeurs des param�tres utilis�es
                            pour cet exemple sont donn�es par le tableau~\ref{image_graphem_segmentation_parametre}.
                            Il reste encore des erreurs. Le seul accent segment� comme tel est celui de l'image "Lahs�ne".
                        }
        \label{image_graphem_resultat}
            \end{figure}


La figure~\ref{image_graphem_resultat} pr�sente quelques r�sultats de cette segmentation obtenue pour les param�tres de la table~\ref{image_graphem_segmentation_parametre} qui ont aussi servi � produire les illustrations interm�diaires. Il subsiste encore des erreurs. L'exp�rience montre qu'il est impossible d'ajuster les param�tres afin de les faire dispara�tre sans g�n�rer des erreurs sur d'autres documents.

Afin d'�valuer la pertinence d'un traitement dissoci� des accents, l'exp�rience suivante anticipe celle du paragraphe~\ref{reco_reco_knn_sequence}\footnote{Le paragraphe~\ref{reco_reco_knn_sequence} (page~\pageref{reco_reco_knn_sequence}) pr�cise la source des donn�es ainsi que la mani�re dont ont �t� constitu�es les bases d'apprentissage et de test.}. Elle consiste � comparer les r�sultats d'une reconnaissance mot, r�alis�e avec une m�thode des plus proches voisins, effectu�e sur des images non segment�es dans un premier temps et segment�es en graph�mes dans un second temps. La table~\ref{image_kppv_word_recognition} reprend ces r�sultats.



                \begin{table}[ht]
                $$\begin{tabular}{|l|l|l|c|}  \hline
                    base & exp�rience                                                            &            jeu                                     &     
                                                        \begin{minipage}[l]{2.5cm}taux de reconnaissance \smallskip \end{minipage}    \\ \hline \hline
                    % ------------------------------------------------------
                    &    non segment�e                                                        & $Mat\pa{10,5}$                      &   68,20 \%          \\ 
                    &    non segment�e                                                        & $Mat\pa{20,10}$                      &   69,45 \%          \\ 
        ICDAR
                    &    segment�e    (accents inclus)                        & $Mat\pa{5,5}$                            &        52,12 \%          \\  
                    &    segment�e    (accents s�par�s)                            & $Mat\pa{5,5}$             &        52,06 \%          \\  
                    &    segment�e    (accents s�par�s + dist)            & $Mat\pa{5,5}$                          &        52,07 \%          \\  \hline \hline
                    % ------------------------------------------------------
                    &    non segment�e                                                        & $Mat\pa{10,5}$                      &   48,16 \%          \\ 
        pr�noms
                    &    non segment�e                                                        & $Mat\pa{20,10}$                      &   57,59 \%          \\ 
        fran�ais
                    &    segment�e    (accents inclus)                        & $Mat\pa{5,5}$                            &        40,21 \%          \\  
                    &    segment�e    (accents s�par�s)                            & $Mat\pa{5,5}$             &        42,04 \%          \\  
                    &    segment�e    (accents s�par�s + dist)            & $Mat\pa{5,5}$                          &        41,96 \%          \\  
                    % ------------------------------------------------------
                    \hline \end{tabular}$$
                \caption{    Taux de reconnaissance pour une reconnaissance de mot � l'aide de plus proches voisins.
                                    Les bases d'apprentissage et de tests contiennent chacune 15000 mots anglais cursifs
                                    appartenant � un vocabulaire de 116 mots diff�rents pour la base ICDAR. Elles contiennent 
                                    �galement 15000 pr�noms fran�ais cursifs parmi une liste de 157 
                                    pour la base des pr�noms fran�ais dont 13,3\% contiennent des accents. 
                                    Les bases d'apprentissage et de test contiennent chacune au moins plus de 100 
                                    occurrences d'un mot pour
                                    la base ICDAR et au moins plus de 50 occurrences pour la base des pr�noms fran�ais.
                                    Chaque exemple de la base d'apprentissage
                                    est class� selon les plus proches voisins dans la base d'apprentissage. Ces voisins 
                                    sont recherch�s � partir d'une distance calcul�e sur l'image non segment�e ou segment�e.}
                \label{image_kppv_word_recognition}
                \end{table}

\indexfrr{dictionnaire}{dynamique}
\indexfrr{dictionnaire}{statique}


L'exp�rience utilise le jeu de caract�ristiques $Mat$ d�crit au paragraphe paragraphe~\ref{reco_graphem_matrice} car ils sont aussi pertinents sur l'image d'un mot que sur l'image d'un graph�me. Tout d'abord, le tableau~\ref{image_kppv_word_recognition} montre que la segmentation fait d�cro�tre les performances obtenues pour cette exp�rience de reconnaissance avec dictionnaire statique, � la fois pour une base d'images de mots anglais et une base d'images de pr�noms fran�ais. La segmentation peut donc �tre per�ue comme une perte d'information n�anmoins n�cessaire dans le cas des vocabulaires dynamiques pour lesquels on ne dispose pas d'exemple pour chacun des mots qu'ils contiennent.

Le second r�sultat concerne trois types de traitements des accents. La premi�re segmentation en graph�mes ne s�pare pas les accents comme il est d�crit au paragraphe~\ref{image_segmentation_connexe_graphem}. Le second traitement enl�ve les accents de la s�quence de graph�mes. La troisi�me option inclut dans la s�quence de caract�ristiques li�es aux graph�mes des caract�ristiques d�crivant les accents selon le m�canisme d�crit au paragraphe~\ref{reco_sel_feat_acc}. Ces trois traitements aboutissent � des performances similaires sur des bases de mots anglais qui ne contiennent comme accents que des points (sur les lettres "i" et "j"). En revanche, pour une base de pr�noms fran�ais, le traitement dissoci� des accents permet d'accro�tre l�g�rement les performances. Toutefois, tenir compte des accents au niveau des caract�ristiques ou les oublier ne semble pas faire de diff�rence.

Ces exp�riences montrent que le traitement des accents n'apporte rien lorsque la langue elle-m�me n'en contient pas mais il n'alt�re rien non plus. Pour une langue incluant des accents, il appara�t pr�f�rable d'en tenir compte, soit de les nettoyer dans les images o� ils apparaissent, soit de les inclure dans les caract�ristiques. Les r�sultats obtenus ne permettent pas de d�terminer si une m�thode est pr�f�rable � une autre. Il reste qu'un traitement dissoci� des accents n'est justifi� que par leur importance dans la langue �tudi�e.










\subsection{Prolongements}
\label{image_prolongement_segmentation_grapheme}

La segmentation en graph�mes propos�e ici utilise un grand nombre de seuils de d�cision (var table~\ref{image_graphem_segmentation_parametre}) que l'exp�rience permet d'ajuster. Au final, le r�sultat est obtenu apr�s l'application successive d'algorithmes vari�s de segmentation ou de regroupement. La m�thode pr�sent�e dans les articles \citeindex{Desolneux2000}, \citeindex{Desolneux2002}, \citeindex{Desolneux2003} (�galement abord�e au paragraphe~\ref{image_nettoyage_desolneux}) offre une direction de recherche int�ressante. Plut�t que de varier les algorithmes, il serait possible de n'utiliser qu'une seule m�thode d�di�e � la d�tection de diff�rentes formes g�om�triques simples telles que les boucles, les ascendants et descendants, les liaisons et autres formes r�currentes de l'�criture. La segmentation s'appuierait sur les fronti�res des formes d�tect�es. Une telle m�thode aurait �galement l'avantage de ne pas utiliser la connexit� entre pixels.

\indexfrr{segmentation}{apprentissage}
\indexfrr{segmentation}{graph�me}

Cette segmentation appara�t comme une multitude de petites recettes appliqu�es les unes � la suite des autres afin de corriger les imperfections des couches pr�c�dentes. Cette premi�re �tape, m�me imparfaite, est n�anmoins n�cessaire afin de construire une premi�re version des mod�les de reconnaissance. Il n'existe pas de d�finition pr�cise de ce qu'est un graph�me mais ce premier jeu de mod�les de reconnaissance permet d'extraire les segmentations qui ont particip� � une bonne reconnaissance. Il serait possible alors de construire une segmentation en graph�mes apprise � partir de ces bons exemples. La conception d'un tel algorithme est une autre direction de recherche possible pour la poursuite de ces travaux.

\indexfrr{directions de recherche}{segmentation graph�me apprise}















%-------------------------------------------------------------------------------------------------------------
\section{Segmentation en mots}
%-------------------------------------------------------------------------------------------------------------
\indexfrr{segmentation}{mot}
\indexfr{histogramme}


Il est possible de segmenter en mots avant ou apr�s la segmentation en graph�mes. Dans le premier cas, la segmentation est semblable � un d�coupage en lignes et utilise des projections de l'image selon une direction verticale. Seuls les seuils sont diff�rents. Dans le cas d'une segmentation en mots s'appuyant sur celle en graph�mes, il s'agit de d�terminer les graph�mes cons�cutifs qui appartiennent � deux mots diff�rents.

\indexfr{r�seau de neurones}

S'il existe des bases de donn�es contenant des images de lignes d�j� segment�es en mots, la seconde m�thode utilisant les graph�mes est mieux adapt�e. Par exemple, la figure~\ref{image_graphe_noel} contient 17 graph�mes, soit au plus seize coupures entre deux mots. Le principe consiste � affecter � chacune de ces coupures une probabilit� de s�parer deux mots, celle-ci est apprise � partir de la base de donn�es et d�pend de param�tres tels que la distance entre les deux graph�mes qui l'entourent, leurs tailles, leurs formes... S'il y a $N$ graph�mes, on obtient $N-1$ probabilit�s de c�sure $\vecteur{p_1}{p_{N-1}}$. A chaque point de c�sure, on associe la variable al�atoire $Y_i \in \acc{0,1}$ v�rifiant $\pr{Y_i = 1} = p_i$. Une segmentation en mots est alors compl�tement d�crite par la donn�e de $\vecteur{Y_1}{Y_{N-1}}$. Comme ces variables al�atoires sont ind�pendantes, la probabilit� associ�e � cette segmentation est~:

            \begin{eqnarray}
            \pr{\vecteurno{Y_1}{Y_{N-1}}} &=& \prody{i=1}{N-1} \; p_i\pa{\theta}^{Y_i} \, \pa{1-p_i\pa{\theta}}^{1-Y_i}
            \label{image_vraisemblance_seg_mot}
            \end{eqnarray}

\indexfr{r�seau de neurones}

Chaque $p_i\pa{\theta}$ est fonction � valeur dans $\cro{0,1}$ et qui d�pend de caract�ristiques $\theta$ extraites de l'image. Cette fonction peut �tre par exemple un r�seau de neurones\seeannex{annexe_reseau_neurone}{r�seau de neurones} estim� en maximisant la vraisemblance~(\ref{image_vraisemblance_seg_mot}) par rapport � $\theta$ sur une base d'images pour laquelle les valeurs $\pa{Y_i}_i$ sont connues. Une fois cette fonction apprise, cette �criture permet de trouver la segmentation en mots la plus probable. Il est �galement parfois utile de conserver les segmentations les plus probables lorsque l'�criture � d�couper est ambigu�.









%--------------------------------------------------------------------------------------------------------------
\section{Post-traitement des graph�mes}
%--------------------------------------------------------------------------------------------------------------


Avant de pouvoir reconna�tre un graph�me ou un caract�re, il faut d�crire son image � l'aide de caract�ristiques qui sont g�n�ralement un vecteur de $\mathbb{R}^n$ o� $n$ est le nombre de caract�ristiques (voir paragraphe~\ref{reco_description_grapheme}, page~\pageref{reco_description_grapheme}). Les graph�mes sont parfois tr�s bruit�s et ce bruit se r�percute sur la qualit� de leur description. Diminuer l'importance de ce bruit peut am�liorer les performances de reconnaissance (voir paragraphe~\ref{reco_restauration_image_graheme}). Ces graph�mes peuvent �galement inclure plusieurs composantes connexes qui nuisent � certaines extractions de caract�ristiques bas�es sur le contour de la forme (voir paragraphe~\ref{reco_connexion_composante_connexe}).









\subsection{Restauration de l'image des graph�mes}
\label{reco_restauration_image_graheme}
\indexfrr{graph�me}{restauration}
\indexfrr{restauration}{graph�me}
\indexfrr{restauration}{caract�re}


\indexfr{contour}
\indexfrr{caract�re}{bruit�}
\indexfr{squelette}

Les caract�res manuscrits sont parfois mal scann�ris�s, la binarisation de l'image aboutit parfois � des caract�res bruit�s qu'il est pr�f�rable de restaurer. L'article \citeindex{Whichello1996} se penche sur un bruit diffus qui se manifeste par la diss�mination de pixels blancs � travers le caract�re � reconna�tre (voir figure~\ref{image_restauration_mbruit}). La squelettisation et en particulier l'extraction de contour d'une telle forme est impossible et m�ne souvent � myriade de petits morceaux proches les uns des autres. La restauration propos�e dans \citeindex{Whichello1996} s'int�resse � l'extraction du contour de la forme bruit�e. 

            \begin{figure}[ht]
        $$\begin{tabular}{|c|} \hline
        \includegraphics[height=1cm, width=1.5cm]{\filext{../image/image/mbruit}}
        \\ \hline  \end{tabular}$$
        \caption{    Lettre "m" bruit�e, la binarisation a conserv� environ un pixel noir sur deux.}
        \label{image_restauration_mbruit}
            \end{figure}

\indexfr{composante connexe}
\indexfr{masque}

La m�thode s'appuie sur des masques dits $\pa{N,M}$, � partir d'un pixel du contour, on cherche le pixel suivant de ce contour non plus sur un voisinage $\pa{3,3}$ comme c'est le cas pour une composante connexe mais sur un voisinage $\pa{N,M}$. La table~\ref{image_restauration_mbruit_masque} illustre les masques $\pa{1,1}$ et $\pa{3,3}$. En partant d'un premier pixel, le pixel suivant est alors le pixel noir dont le num�ro est le plus faible. Le masque est ensuite tourn� selon la direction du d�placement pr�c�demment trouv�.

            \begin{table}[ht]
            $$ \begin{tabular}{ccc}
                \begin{tabular}{|c|c|c|} \hline
                4    &    3    & 2 \\ \hline
                5    &    0    & 1 \\ \hline
                6    &    7    & 8 \\ \hline
                \end{tabular}
                & &
                \begin{tabular}{|c|c|c|c|c|c|c|} \hline
                19    & 18    & 16    & 13    & 12    & 10    & 7        \\ \hline
                22    & 20    & 17    & 14    & 11    & 8        & 6        \\ \hline
                24    & 23    & 21    & 15     & 9        & 5        & 4        \\ \hline
                25    & 26    & 27    & 0        & 3        & 2        & 1        \\ \hline
                28    & 29    & 33    & 39    & 45    & 47    & 48    \\ \hline
                30    & 32    & 35    & 38    & 41    & 44    & 46    \\ \hline
                31    & 34    & 36    & 37    & 40    & 42    & 43    \\ \hline
                \end{tabular} \\ 
                masque $\pa{1,1}$ & & masque $\pa{3,3}$  
                \end{tabular} $$
            \caption{    Masques de diff�rentes tailles pour la recherche du contour, les cases sont num�rot�es par 
                                angle croissant et par distance au centre d�croissante. Les autres masques sont obtenus en effectuant
                                des rotations des positions.}
            \label{image_restauration_mbruit_masque}
            \end{table}
                

\indexfr{composante connexe}
\indexfr{squelette}

L'article \citeindex{Wang1999} s'attaque � un autre type de d�t�rioration des caract�res. La connexit� peut �tre bris�e lorsque le caract�re d�passe du cadre de l'image ou qu'une partie est escamot�e apr�s une binarisation trop rugueuse (voir figure~\ref{image_restauration_mbruitwang}a). L'algorithme suppose que l'image ne contient qu'une seule composante connexe et cherche � recoller les morceaux si elle en contient plus d'un. Les extr�mit�s du squelette sont prolong�es afin d'atteindre une autre composante connexe. Le prolongement est cependant contraint par la courbure du squelette � ses extr�mit�s.


            \begin{figure}[ht]
        $$\begin{tabular}{|c|c|} \hline
        \includegraphics[height=4cm, width=4cm]{\filext{../image/image/cutwang}} &
        \includegraphics[height=2cm, width=2cm]{\filext{../image/image/cutwang2}} \\
        $(a)$ & $(b)$ 
        \\ \hline  \end{tabular}$$
        \caption{    Figure extraite de \citeindexfig{Wang1999}, les deux chiffres sont incomplets. Les extremit�s
                            du squelette sont alors prolong�es. La figure $b$ illustre le co�t d'un changement de direction par
                            rapport � une direction verticale.}
        \label{image_restauration_mbruitwang}
            \end{figure}

La figure~\ref{image_restauration_mbruitwang}b permet d'illustrer le co�t d'un changement de direction lors du prolongement. A chaque pixel est tout d'abord associ�e une distance nulle s'il est une extr�mit� du squelette, infinie dans le cas contraire et un vecteur tangente tenant compte de l'orientation du squelette � son extremit�. Cette information est propag�e par l'interm�diaire d'une carte de distance\seeannex{ske_carte_distance_sec}{carte de distance} utilisant un masque calcul� � partir du sch�ma~\ref{image_restauration_mbruitwang}b. Les liaisons les moins co�teuses sont conserv�es de mani�re � ne former plus qu'une seule composante connexe. Une fois le squelette reconstitu�, ce dernier est enrob� d'une �paisseur de pixels conforme � celle du reste de la figure.

\indexfr{ondelettes}

L'article \citeindex{Hwang1998} s'int�resse aux documents imprim�s dont les caract�res apparaissent en traits trop gras. Les boucles caract�res ne sont d�celables, noy�es par l'�paisseur des traits. Les auteurs utilisent une m�thode fond�e sur des ondelettes, ces derni�res permettant de d�tecter la pr�sence de segments rectilignes dans une image en niveaux de gris. Cette d�tection termin�e, leur configuration permet de supposer la pr�sence de boucles et ainsi de binariser l'image sans commettre trop d'erreurs (voir figure~\ref{image_restauration_hwang}).


            \begin{figure}[ht]
        $$\begin{tabular}{|c|c|c|} \hline
        \includegraphics[height=3cm, width=3cm]{\filext{../image/image/hawang1}} &
        \includegraphics[height=3cm, width=3cm]{\filext{../image/image/hawang2}} &
        \includegraphics[height=3cm, width=3cm]{\filext{../image/image/hawang3}} 
        \\ \hline  \end{tabular}$$
        \caption{    Figure extraite de \citeindexfig{Hwang1998}, la premi�re image est l'image originale tandis
                            que la seconde est le r�sultat du traitement propos� dans \citeindexfig{Hwang1998}. Cette 
                            binarisation est difficilement accessible aux m�thodes reposant sur les simples
                            histogrammes repr�sentant la densit� des niveaux de gris (troisi�me image).
                        }
        \label{image_restauration_hwang}
            \end{figure}





La figure~\ref{image_restauration_o}a montre le dessin d'une lettre "o" partiellement escamot�e par la scannerisation. L'\oe il humain peut facilement reconna�tre la lettre "o" m�me si elle est compos�e de deux morceaux. Toutefois, la figure~\ref{image_restauration_o}b montre un exemple o� il est parfois impossible d'effectuer cette restauration sans avoir connaissance du contexte.


            \begin{figure}[ht]
        $$\begin{array}{|c|c|c|} \hline
        \includegraphics[height=2cm, width=5cm]{\filext{../image/image/restaure}} &
        \includegraphics[height=2cm, width=2.5cm]{\filext{../image/image/restaure_au}} &
        \includegraphics[height=2cm, width=2cm]{\filext{../image/image/restm}} \\
        $(a)$ & $(b)$ & $(c)$ \\ \hline
        \end{array}$$
        \caption{    Restauration souhait�e de l'image d'une lettre "o" et restauration ambigu� d'une lettre 
                            qui pourrait �tre soit~"a" soit~"u". L'image~(c) montre le r�sultat obtenu pour une lettre~$M$
                            et une valeur de $\alpha$ n�gligeable (voir expression~\ref{image_restauration_equation}). 
                            La perte de connexit� a �t� corrig�e en alt�rant toutefois le reste de l'image. De petits ergots 
                            se sont accroch�s sur la partie sup�rieure de la lettre de fa�on � cr�er artificiellement
                            des lignes � trois transitions comme c'est habituellement le cas pour une lettre~"M".}
        \label{image_restauration_o}
            \end{figure}


A partir d'une classification non supervis�e des graph�mes obtenue gr�ce � un jeu de caract�ristiques tels que ceux pr�sent�s aux paragraphes~\ref{reco_graphem_matrice} ou~\ref{reco_graphem_histo}, il est possible de d�terminer des formes litigieuses, pour lesquelles la classification est ambigu�. Plut�t que de laisser ce doute, la reconnaissance pourrait �tre am�lior�e si l'image de d�part �tait modifi�e de fa�on � se rapprocher de l'une des classes avoisinant ce graph�me.

Soit $v\pa{G}$ un vecteur de caract�ristiques attach� � un graph�me~$G$ et~$v\pa{H}$ le vecteur attach� au graph�me~$H$ qui est un exemple repr�sentatif d'une classe quelconque, est-il possible de trouver une forme $G'$ obtenue par une transformation $f$ de co�t $c_f$ telle que~:

        $$
        d\pa{v\pa{G'},v\pa{H}} + c_f \infegal d\pa{v\pa{G},v\pa{H}} 
        $$

\indexfrr{carte}{distance}

$G$ est une image dont il est possible d'extraire le contour. A partir de celui-ci, on construit une carte de distance $D_G$ selon la m�thode utilis�e en annexe\seeannex{ske_def_cart_dist_def}{carte de distance}, cette carte contient pour chaque pixel la distance au pixel noir le plus proche. Pour $\alpha > 0$, la forme $G^*_\alpha$ restaur�e est celle qui permet d'atteindre le minimum suivant $G^*_\alpha$~:

        \begin{eqnarray}
        G^*_\alpha \in \underset{G'}{\arg \min} \cro{ d\pa{v\pa{G'},v\pa{H}} + 
                            \alpha \; \summyone{x,y} \; \abs{G'\pa{x,y} - G\pa{x,y}} \; D_G\pa{x,y} }
                            \label{image_restauration_equation}
        \end{eqnarray}

Les diff�rences entre $G^*_\alpha$ et $G$ sont pond�r�es par leur �loignement par rapport au contour de la forme initiale. Il reste � ajuster $\alpha$ de telle sorte que la restauration ne soit pas trop �loign�e de la forme d'origine ni trop discr�te. Le meilleur moyen de mesurer l'apport d'une telle m�thode est de comparer les performances en reconnaissance entre l'image non restaur�e et l'image restaur�e. Il est �galement possible de changer l'�quation (\ref{image_restauration_equation}) en~(\ref{image_restauration_equation_2})~:

        \begin{eqnarray}
        G^*_\alpha &\in& \underset{G'}{\arg \min} \cro{ f\pa{v\pa{G'}} + 
                            \alpha \; \summyone{x,y} \; \abs{G'\pa{x,y} - G\pa{x,y}} \; D_G\pa{x,y} } 
                            \label{image_restauration_equation_2} \\
        && \text{ avec } f\pa{v\pa{G'}} \text{ densit� du vecteur } v\pa{G'} 
                                \text{ (voir paragraphe~\ref{reco_densite_valeur_aberrante})} \nonumber
        \end{eqnarray}


\indexfr{homotope}

En supposant raisonnablement que la forme $G^*$ doit rester homotope\seeannex{annexe_squelettisation}{squelettisation} � $G$, il est possible de r�duire la complexit� lors de la recherche du minimum des �quations (\ref{image_restauration_equation}) et (\ref{image_restauration_equation_2}) en classant les pixels par ordre croissant de distance $D_G\pa{x,y}$. Ceci aboutit � l'algorithme approch� suivant~:

            \begin{xalgorithm}{restauration}
            Soient $G$ et $H$ deux graph�mes, l'objectif est de restaurer $G$ en prenant $H$ comme mod�le. 
            Soit $\alpha > 0$.
            La carte de distance $D_G\pa{x,y}$ est construite � partir de l'image du contour en utilisant
            l'algorithme~\ref{ske_algo_cart_dist}. On suppose �galement que $\vecteur{p_1}{p_n}$ est une suite 
            de pixels v�rifiant~:
            
                    $$
                    \begin{array}{rl}
                    \forall i,                 & G\pa{p_i} \neq H\pa{p_i} \\
                    \forall \pa{i,j}, &  i \infegal j \Longrightarrow D_G\pa{p_i} \infegal D_G\pa{p_j}
                    \end{array}
                    $$
            
            
            \begin{xalgostep}{initialisation}
            $\begin{array}{lll}
            G' &\longleftarrow& G \\
            m  &\longleftarrow& d\pa{v\pa{G},v\pa{H}}
            \end{array}$
            \end{xalgostep}
            
            \begin{xalgostep}{restauration}
            \begin{xfor}{i}{1}{n}
            $\begin{array}{lll}
            G^t                 &\longleftarrow& G' \\
            G^t\pa{p_i} &\longleftarrow& H\pa{p_i} \\
            m^t                    &\longleftarrow& d\pa{v\pa{G^t},v\pa{H}} + \alpha D_G\pa{p_i}
            \end{array}$ \\
            \begin{xif}{$m^t < m$}
            $\begin{array}{lll}
            G' &\longleftarrow& G^t \\
            m  &\longleftarrow& m^t
            \end{array}$
            \end{xif}
            \end{xfor}
            \end{xalgostep}
            
            \end{xalgorithm}
        

        
\indexfr{caract�ristiques}        
\indexfrr{classification}{non supervis�e}
        
        
Pour tester cet algorithme de restauration, la m�thode utilis�e s'inspire de celle permettant de s�lectionner le meilleur jeu de caract�ristiques (voir paragraphe~\ref{reco_selection_caracteristique}, page~\pageref{reco_selection_caracteristique}). Un premier jeu de caract�ristiques est choisi de mani�re � effectuer une classification non supervis�e dont le nombre de classes est choisi d'apr�s le crit�re de Davies-Bouldin\seeannex{classification_selection_nb_classe_bouldin}{Davies-Bouldin}. Un second jeu de caract�ristiques est choisi de mani�re � effectuer une classification par la m�thodes des plus proches voisins. Quatre tests sont effectu�s~:

            \begin{enumerate}
            \item Le premier test sert de rep�re~: un caract�re non restaur� de la base de test est class� 
                        par rapport � ses voisins non restaur�s dans la base d'apprentissage. Ce test est nomm� $App \, Test$.
            \item Le second test est un compromis~: un caract�re non restaur� de la base de test est class� 
                        par rapport � ses voisins restaur�s dans la base d'apprentissage. Ce test est nomm� $App^r \, Test$.
            \item Le troisi�me test est un autre compromis~: un caract�re restaur� de la base de test est class� 
                        par rapport � ses voisins non restaur�s dans la base d'apprentissage. Ce test est nomm� $App \, Test^r$.
            \item Le dernier test~: un caract�re restaur� de la base de test est class� 
                        par rapport � ses voisins restaur�s dans la base d'apprentissage. Ce test est nomm� $App^r \, Test^r$.
            \end{enumerate}
            
            

\indexfrr{test}{$App \, Test$}
\indexfrr{test}{$App^r \, Test$}
\indexfrr{test}{$App \, Test^r$}
\indexfrr{test}{$App^r \, Test^r$}

            \begin{table}[ht]
            $$\begin{tabular}{|c|c|c|cccc|} \hline
                                       & nombre de &                       &            &              &              &                \\
            $1^{er}$ jeu   & classes   &    $2^{\text{�me}}$ jeu & $App \, Test$    & $App^r \, Test$ & 
                                                                                                                $App \, Test^r$    & $App^r \, Test^r$ \\ \hline
            $Prof\pa{5,5}$ &  8    &  $Prof\pa{5,5}$  & 90,88 \% &    87,84 \%    &         90,58 \% &    91,79  \%             \\ \hline
            \end{tabular}$$
            \caption{ R�sultats obtenus concernant la restauration d'images 
                              (la d�signation du jeu de caract�ristiques reprend celle de la figure~\ref{reco_carac_distance_assoc}, 
                              page~\pageref{reco_carac_distance_assoc}) pour les quatre tests 
                              $App \, Test$, $App^r \, Test$, $App \, Test^r$, $App^r \, Test^r$. Ces r�sultats ont �t� obtenus
                              avec environ 2000~images dans les bases d'apprentissage et de test et quatre classes de caract�res, 
                              "M", "N", "U", "V".}
            \label{image_restau_test_app_test_feat}
            \end{table}
    
        
Pour chaque test, le taux de reconnaissance est estim�, les r�sultats de ces quatre tests sont r�sum�s dans la table~\ref{image_restau_test_app_test_feat}. Etant donn� les temps de traitements, ces r�sultats ont �t� obtenus sur de petites bases d'apprentissage et de test (2000~images chacune) et quatre classes de caract�res � identifier. Les r�sultats sont meilleurs que pour une reconnaissance ne prenant pas en compte la restauration. Afin d'expliquer ce gain, on d�nombre dans chacune des deux bases d'apprentissage restaur�e et non restaur�e le nombre d'images pour lesquelles les $k$ plus proches voisins appartiennent � la m�me classe (voir table~\ref{image_reco_kppv_restauration}). Cette proportion d�cro�t avec $k$ mais reste toujours sup�rieure pour la base d'images restaur�es, la restauration des images s�pare mieux les classes.

\indexfr{kPPV}
\indexfr{k plus proche voisins}

                        \begin{table}[ht]
                        $$\begin{tabular}{|c|cccc|}\hline 
                        $k$                                    & 1                & 2                & 3                & 4          \\  \hline
                        base non restaur�e    & 91,3\%    & 88,2\%    & 85,2\%    & 81,7\% \\
                        base restaur�e            & 93,9\%    & 91,7\%    & 89,1\%    & 88,2\% \\ \hline
                        \end{tabular}$$
                        \caption{ Nombre d'images dont les $k$ plus proches voisins appartiennent � la m�me classe. 
                                          Cette proportion d�cro�t avec $k$ mais reste toujours sup�rieure pour la base d'images
                                          restaur�es.}
                        \label{image_reco_kppv_restauration}
                        \end{table}
                        
                        

                        
                        
                        
                        



\subsection{Connexion de plusieurs composantes connexes}
\label{reco_connexion_composante_connexe}

\indexfr{abscisse curviligne}
\indexfr{composante connexe}
\indexfr{centre de gravit�}
\indexfr{contour}
\indexfrr{recollement}{composante connexe}

Certaines descriptions de graph�mes utilisent des caract�ristiques extraites � partir du contour de l'image. Le contour est alors consid�r� comme une fonction continue~: $f : s \in \cro{0,1} \rightarrow \mathbb{R}$ o� $s$ est l'abscisse curviligne. Dans le cas des caract�ristiques d�crites aux paragraphes~\ref{reco_profil_polair} et~\ref{reco_feature_fourier_contour} (pages~\pageref{reco_profil_polair} et~\pageref{reco_feature_fourier_contour}), la fonction $f$ est la distance du point du contour dont l'abscisse curviligne est $s$, au centre de gravit� de l'image. Cette m�thode n'est pas applicable dans le cas o� l'image contient plusieurs composantes connexes. Il devient n�cessaire de les relier entre elles afin d'extraire un seul contour. Le paragraphe~\ref{reco_restauration_image_graheme} mentionne l'article \citeindex{Wang1999} qui recolle les morceaux d'une lettre, la m�thode utilis�e ici est plus simple mais peut �tre consid�r�e comme un cas particulier.


\indexfrr{carte}{distance}

L'id�e d�velopp�e ici s'inspire en partie des travaux de \citeindex{Wang1999}. Une carte des distances\seeannex{ske_carte_distance_sec}{carte de distance} est d'abord extraite de l'image $I$. A chaque pixel $\pa{x,y}$ sont alors associ�es deux informations~:

                $$\begin{tabular}{ll}
                $pix_I\pa{x,y}$     & est le pixel noir le plus proche du pixel $\pa{x,y}$ \\
                $dist_I\pa{x,y} = d\pa{\pa{x,y}, \; pix_I\pa{x,y}}$  & 
                                                        est la distance du pixel $\pa{x,y}$ au pixel noir le plus proche 
                \end{tabular}$$
                
L'objectif consiste � relier deux composantes connexes diff�rentes par une ligne. Ces lignes doivent �tre les plus courtes possible afin de ne pas trop alt�rer l'image originale. Par cons�quent, on cherche d'abord les pixels voisins dont les pr�d�cesseurs appartiennent � des composantes connexes diff�rentes. Les lignes qui doivent les relier passent n�cessairement pas ces points situ�s � mi-chemin entre deux composantes connexes, il suffit alors de s�lectionner ceux pour lesquels la distance $dist_I\pa{x,y}$ est la plus courte. Ceci d�bouche sur l'algorithme suivant~:


            \begin{xalgorithm}{connexion de composantes connexes}
            Les notations sont celles utilis�es dans ce paragraphe, � chaque pixel de l'image $I$ est associ� le pixel
            $pix_I\pa{x,y}$ d�fini plus haut. On suppose �galement que $C\pa{x,y}$ est l'indice de la composante 
            connexe � laquelle appartient le pixel $\pa{x,y}$. On d�signe le voisinage d'un pixel $\pa{x,y}$
            par l'ensemble~:
                    
                    $$
                    V\pa{x,y} = \acc{ \pa{x',y'} \sac \pa{x',y'} \neq \pa{x,y}, \; \abs{x'-x} \infegal 1, 
                                                                \; \abs{y'-y} \infegal 1 }
                    $$

            \begin{xalgostep}{tri de l'ensemble $F$}
            $F \longleftarrow \emptyset$ \\
            \begin{xforeach}{\pa{x,y}}{I}
                \begin{xforeach}{\pa{x',y'}}{V\pa{x,y}}                
                    \begin{xif}{$C\pa{pix_I\pa{x,y}} \neq C\pa{pix_I\pa{x',y'}}$}
                            $F \longleftarrow F \cup \acc{ \pa{x,y} }$
                    \end{xif}
                \end{xforeach}
            \end{xforeach}
            \end{xalgostep}

            \begin{xalgostep}{connexion des composantes connexes}
            L'ensemble $F$ est tri�, on note $F = \vecteur{p_1}{p_M}$, il v�rifie~:
                    $$
                            \forall i, \; dist_I\pa{p_i} \infegal dist_I\pa{p_{i+1}}
                    $$
            \end{xalgostep}
            
            %\possiblecut
            
            \begin{xalgostep}{choix des pixels sur les fronti�res}
                    $c \longleftarrow $ le nombre de composantes connexes \\
                    $i \longleftarrow 1 $\\
                    \begin{xwhile}{$c > 1$}
                       $c_1 \longleftarrow C\pa{pix_I\pa{p_i}}$ \\
                       \begin{xif}{ il existe un voisin $q$ de $p_i$ tel que $C\pa{pix_I\pa{q}} \neq c_1$}
                               $c_2 \longleftarrow C\pa{pix_I\pa{q}}$ \\
                               On trace la ligne reliant les points $pix_I\pa{p_i}$ et $pix_I\pa{q}$. \\
                               $c \longleftarrow c-1$ \\
                               \begin{xforeach}{\pa{x,y}}{I}
                                   \begin{xif}{$C\pa{x,y} = c_2$}
                                       $C\pa{x,y} \longleftarrow c_1$ 
                                   \end{xif}
                             \end{xforeach}
                       \end{xif} \\
                       $i \longleftarrow i + 1$
                    \end{xwhile}
            \end{xalgostep}
            \end{xalgorithm}



Un exemple est donn� par la figure~\ref{image_connexion_composante_connexion_a}. La lettre $A$ est compos�e de cinq composantes connexes, chacune est reli�e � la plus grande d'entre elles. Il est maintenant possible de n'extraire qu'un seul contour de cette image.



            \begin{figure}[ht]
        $$\begin{array}{|c|c|} \hline
        \includegraphics[height=2cm, width=2cm]{\filext{../image/image/conal1}} &
        \includegraphics[height=2cm, width=2cm]{\filext{../image/image/conal2}} \\
        $(a)$ & $(b)$ \\ \hline
        \end{array}$$
        \caption{    Connexion de composantes connexes, la premi�re image contient quatre composantes
                            connexes dont un pixel isol�. Apr�s leur connexion, il n'en reste plus qu'une~:
                            toutes ont �t� reli�es � la plus grande d'entre elles.}
        \label{image_connexion_composante_connexion_a}
            \end{figure}














%-------------------------------------------------------------------------------------------------------------
\section{Conclusion}
%-------------------------------------------------------------------------------------------------------------
\label{image_conclusion}


Disposant d�j� d'une segmentation en graph�mes\footnote{Celle utilis�e dans la th�se \citeindex{Augustin2001}.} fond�e sur des heuristiques, l'objectif �tait d'inclure lors de cette �tape une partie apprentissage. Cependant, les m�thodes actuelles de segmentations d'image fond�es sur des optimisations concernent l'extraction de r�gions ou la segmentation de textures. La premi�re direction de recherche fut alors l'�laboration d'une segmentation dont les param�tres seraient appris en tenant compte notamment du voisinage des fronti�res. Mais l'id�e d�velopp�e n'a pas obtenu de r�sultats satisfaisants. 

Ces travaux se sont ensuite orient�s vers le probl�me des accents en langue fran�aise qui occasionnent souvent des erreurs de segmentation. A l'aide d'une segmentation en graph�mes inspir�s d'algorithmes existants, des exp�riences ont alors montr� qu'un traitement dissoci� am�liore l�g�rement les performances en reconnaissance et ne les d�t�riore pas lorsque la langue de l'exp�rience ne contient pas d'accents. La derni�re contribution concerne la restauration des graph�mes abord�e ici d'un point de vue statistique, la m�thode propos�e est lente mais obtient des r�sultats attrayants � condition de r�ellement acc�l�rer ce processus.

De plus, cette partie s'est attach�e � d�tailler les pr�traitements permettant de d�crire l'information contenue dans l'image sous une forme plus exploitable, une s�quence de graph�mes, ceux-ci sont ensuite utilis�s par les mod�les de reconnaissance statistique. Ce processus permet donc de diviser le probl�me de la reconnaissance d'un paragraphe en une succession de reconnaissances de mots isol�s. Il inclut les �tapes suivantes~:
        
            \begin{enumerate}
            \item extraction de la zone � reconna�tre
            \item binarisation
            \item nettoyage (soulignement par exemple)
            \item correction de l'inclinaison des lignes
            \item segmentation en lignes
            \item correction de l'inclinaison des lettres
            \item segmentation en graph�mes
            \item segmentation en mots
            \end{enumerate}


La suite concerne la mod�lisation probabiliste des s�quences de graph�mes au travers de mod�les de Markov cach�s.










\newpage

\firstpassagedo{
    \begin{thebibliography}{99}
    \input{image_article.tex}
    \end{thebibliography}
}



\input{../../common/livre_table_end.tex}%
\input{../../common/livre_end.tex}%
